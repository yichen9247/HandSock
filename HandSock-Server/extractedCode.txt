package com.server.handsock.utils
import oshi.SystemInfo
import java.lang.management.ManagementFactory
object SystemUtils {
    val systemUptime: String
        get() {
            val uptime = ManagementFactory.getRuntimeMXBean().uptime
            var seconds = uptime / 1000
            val days = seconds / 86400
            seconds %= 86400
            val hours = seconds / 3600
            seconds %= 3600
            val minutes = seconds / 60
            seconds %= 60
            return String.format("%d天%d小时%d分钟%d秒", days, hours, minutes, seconds)
        }
    val systemMemoryUsage: String
        get() {
            val memory = SystemInfo().hardware.memory
            val totalMemory = memory.total // 总内存
            val availableMemory = memory.available // 可用内存
            val usedMemory = totalMemory - availableMemory // 已使用内存
            return HandUtils.formatBytesForString(usedMemory) + "/" + HandUtils.formatBytesForString(totalMemory)
        }
}
package com.server.handsock.utils
import com.server.handsock.clients.service.ClientChatService
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.ClientService
object RobotUtils {
    fun sendRobotMessage(
        gid: Long,
        content: String,
        address: String,
        clientService: ClientService,
        clientUserService: ClientUserService,
        clientChatService: ClientChatService
    ): Map<String, Any> {
        val robotUser = clientUserService.robotInnerStatus ?: return HandUtils.handleResultByCode(500, null, "未查找到机器人账号")
        if (robotUser.taboo == "open") return HandUtils.handleResultByCode(500, null, "机器人账号已被禁言")
        val sendResult = clientChatService.insertChatMessage(type = "text", robotUser.uid, gid, address, content)
        @Suppress("UNCHECKED_CAST")
        if (clientService.getClientData(sendResult as Map<String?, Any>, "code").toInt() == 200) {
            HandUtils.sendRoomMessageApi(
                gid = gid.toString(),
                event = "[MESSAGE]",
                content = sendResult["data"],
                server = GlobalService.socketIOServer!!
            )
        }
        return sendResult
    }
}
package com.server.handsock.utils
import com.google.zxing.BarcodeFormat
import com.google.zxing.EncodeHintType
import com.google.zxing.common.BitMatrix
import com.google.zxing.qrcode.QRCodeWriter
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel
import java.awt.image.BufferedImage
import java.io.ByteArrayOutputStream
import java.util.*
import javax.imageio.ImageIO
object QrcodeUtils {
    fun generateQrcode(content: String): String {
        val writer = QRCodeWriter()
        val hints = HashMap<EncodeHintType, Any>()
        hints[EncodeHintType.MARGIN] = 0
        hints[EncodeHintType.CHARACTER_SET] = "UTF-8"
        hints[EncodeHintType.ERROR_CORRECTION] = ErrorCorrectionLevel.H
        val bitMatrix = writer.encode(content, BarcodeFormat.QR_CODE, 200, 200, hints)
        return base64ToDataURL(imageToBase64(toBufferedImage(bitMatrix)))
    }
    private fun toBufferedImage(bitMatrix: BitMatrix): BufferedImage {
        val width = bitMatrix.width
        val height = bitMatrix.height
        val image = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)
        for (x in 0 until width) {
            for (y in 0 until height) {
                image.setRGB(x, y, if (bitMatrix[x, y]) 0xFF000000.toInt() else 0xFFFFFFFF.toInt())
            }
        }
        return image
    }
    private fun imageToBase64(image: BufferedImage): String {
        val byteArrayOutputStream = ByteArrayOutputStream()
        ImageIO.write(image, "png", byteArrayOutputStream)
        val imageBytes = byteArrayOutputStream.toByteArray()
        return Base64.getEncoder().encodeToString(imageBytes)
    }
    private fun base64ToDataURL(base64String: String): String {
        return "data:image/png;base64,${base64String}"
    }
}
package com.server.handsock.utils
import java.util.*
object IDGenerator {
    fun generateUniqueId(): String {
        return UUID.randomUUID().toString()
    }
    fun generateRandomId(length: Int): Long {
        val currentYear = Calendar.getInstance()[Calendar.YEAR]
        val yearPrefix = currentYear.toString().substring(if (currentYear - 2000 > 0) 2 else 0)
        val random = Random()
        val randomSuffix = String.format("%0" + length + "d", random.nextInt(1000000))
        return (yearPrefix + randomSuffix).toLong()
    }
    fun generateRandomMessageId(uid: Long, gid: Long, address: String): String {
        return HandUtils.encodeStringToMD5(
            UUID.randomUUID().toString() + "-" + HandUtils.encodeStringToMD5(
                uid.toString() + gid.toString() + address
            )
        )
    }
    fun generateRandomReportedId(sid: String, reporterId: Long, reportedId: Long): String {
        return HandUtils.encodeStringToMD5(
            UUID.randomUUID().toString() + "-" + HandUtils.encodeStringToMD5(
                sid + reporterId + reportedId
            )
        )
    }
    fun generateRandomFileId(uid: Long, name: String, path: String, time: String): String {
        return HandUtils.encodeStringToMD5(
            UUID.randomUUID().toString() + "-" + HandUtils.encodeStringToMD5(
                uid.toString() + name + path + time
            )
        )
    }
}
package com.server.handsock.utils
import com.corundumstudio.socketio.SocketIOClient
import com.corundumstudio.socketio.SocketIOServer
import org.springframework.web.multipart.MultipartFile
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import java.util.*
import java.util.regex.Pattern
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec
import javax.imageio.ImageIO
object HandUtils {
    private const val CODE_KEY = "yichen9247-44052"
    private const val USERNAME_PATTERN = "^[a-zA-Z0-9_-]{3,16}$"
    private const val PASSWORD_PATTERN = "^[a-zA-Z0-9_@#$%^&*!-]{6,18}$"
    fun printErrorLog(e: Exception): Map<String, Any> {
        ConsoleUtils.printErrorLog(e)
        return handleResultByCode(500, null, "服务端异常")
    }
    fun isValidUsername(username: String): Boolean {
        return !username.matches(USERNAME_PATTERN.toRegex()) || username.length < 5 || username.length > 20
    }
    fun isValidPassword(password: String): Boolean {
        return !password.matches(PASSWORD_PATTERN.toRegex()) || password.length < 6 || password.length > 20
    }
    fun stripHtmlTagsForString(html: String): String {
        return Pattern.compile("<.*?>", Pattern.DOTALL).matcher(html).replaceAll("")
    }
    fun formatBytesForString(bytes: Long): String {
        return if (bytes < 1024) {
            bytes.toString() + "B"
        } else if (bytes < 1024 * 1024) {
            String.format("%.1fKB", bytes / 1024.0)
        } else if (bytes < 1024L * 1024L * 1024L) {
            String.format("%.1fMB", bytes / (1024.0 * 1024))
        } else String.format("%.1fGB", bytes / (1024.0 * 1024 * 1024))
    }
    fun handleResultByCode(code: Int, data: Any?, message: String): Map<String, Any> {
        val result: MutableMap<String, Any> = HashMap()
        result["code"] = code
        result["message"] = message
        if (data != null) result["data"] = data
        return result
    }
    fun formatTimeForString(pattern: String?): String {
        val now = OffsetDateTime.now()
        val formatter = pattern?.let { DateTimeFormatter.ofPattern(it) }
        return now.format(formatter)
    }
    fun sendGlobalMessage(server: SocketIOServer, event: String, content: Any?) {
        val broadcastOperations = server.broadcastOperations
        broadcastOperations.sendEvent(event, content)
    }
    fun sendRoomMessage(server: SocketIOServer, client: SocketIOClient, event: String, content: Any?) {
        @Suppress("UNCHECKED_CAST")
        val headers = client.handshakeData.authToken as Map<String, Any>
        sendRoomMessageApi(server, headers["gid"].toString(), event, content)
    }
    fun sendRoomMessageApi(server: SocketIOServer, gid: String, event: String, content: Any?) {
        val broadcastOperations = server.getRoomOperations(gid)
        broadcastOperations.sendEvent(event, content)
    }
    fun checkImageValidExtension(file: MultipartFile): Boolean {
        val fileName = checkNotNull(file.originalFilename)
        val isValidExtension = fileName.endsWith(".jpg")
                || fileName.endsWith(".gif")
                || fileName.endsWith(".png")
                || fileName.endsWith(".jpeg")
                || fileName.endsWith(".webp")
        if (!isValidExtension) return false
        try {
            ImageIO.read(file.inputStream) ?: return false
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
            return false
        }
        return true
    }
    fun encodeStringToSHA256(input: String): String {
        val digest = MessageDigest.getInstance("SHA-256")
        val encodedHash = digest.digest(input.toByteArray(StandardCharsets.UTF_8))
        val hexString = StringBuilder(2 * encodedHash.size)
        for (b in encodedHash) {
            val hex = Integer.toHexString(0xff and b.toInt())
            if (hex.length == 1) hexString.append('0')
            hexString.append(hex)
        }
        return hexString.toString()
    }
    fun encodeStringToMD5(text: String): String {
        val md = MessageDigest.getInstance("MD5")
        val messageDigest = md.digest(text.toByteArray())
        val hexString = StringBuilder()
        for (b in messageDigest) {
            val hex = Integer.toHexString(0xff and b.toInt())
            if (hex.length == 1) hexString.append('0')
            hexString.append(hex)
        }
        return hexString.toString()
    }
    fun encryptString(input: String): String {
        val secretKey = SecretKeySpec(CODE_KEY.toByteArray(), "AES")
        val cipher = Cipher.getInstance("AES")
        cipher.init(Cipher.ENCRYPT_MODE, secretKey)
        val encryptedBytes = cipher.doFinal(input.toByteArray())
        return Base64.getEncoder().encodeToString(encryptedBytes)
    }
    fun decryptString(encrypted: String): String {
        val secretKey = SecretKeySpec(CODE_KEY.toByteArray(), "AES")
        val cipher = Cipher.getInstance("AES")
        cipher.init(Cipher.DECRYPT_MODE, secretKey)
        val decodedBytes = Base64.getDecoder().decode(encrypted)
        val decryptedBytes = cipher.doFinal(decodedBytes)
        return String(decryptedBytes)
    }
}
package com.server.handsock.utils
import com.corundumstudio.socketio.SocketIOServer
import lombok.Setter
import org.springframework.stereotype.Component
import org.springframework.stereotype.Service
@Setter @Component @Service
object GlobalService {
    var socketIOServer: SocketIOServer? = null
}
package com.server.handsock.utils
import com.fasterxml.jackson.databind.ObjectMapper
import org.springframework.web.client.RestTemplate
import java.util.stream.Collectors
import java.util.stream.IntStream
import kotlin.math.min
object ExternalFetcher {
    private val restTemplate = RestTemplate()
    val hitokoto: String?
        get() {
            try {
                return restTemplate.getForObject(
                    "https://international.v1.hitokoto.cn/?encode=text",
                    String::class.java
                )
            } catch (e: Exception) {
                ConsoleUtils.printErrorLog(e)
                return "操作失败，请查看系统日志"
            }
        }
    val weiboHotSearch: String
        get() {
            try {
                val objectMapper = ObjectMapper()
                val result: Map<*, *>? = objectMapper.readValue(
                    restTemplate.getForObject(
                        "https://weibo.com/ajax/side/hotSearch",
                        String::class.java
                    ), Map::class.java
                )
                val dataMap = result?.get("data") as Map<*, *>?
                if (dataMap != null) {
                    @Suppress("UNCHECKED_CAST")
                    val data = dataMap["realtime"] as List<Map<String, Any>>?
                    return IntStream.range(0, min(data!!.size.toDouble(), 10.0).toInt())
                        .mapToObj { i: Int -> "${i + 1}、${data[i]["word"]}" }
                        .collect(Collectors.joining("<br/>"))
                }
            } catch (e: Exception) {
                ConsoleUtils.printErrorLog(e)
            }
            return "操作失败，请查看系统日志"
        }
    val bilibiliHotSearch: String
        get() {
            try {
                val objectMapper = ObjectMapper()
                val result: Map<*, *>? = objectMapper.readValue(
                    restTemplate.getForObject(
                        "https://api.bilibili.com/x/web-interface/wbi/search/square?limit=10",
                        String::class.java
                    ), Map::class.java
                )
                val dataMap = result?.get("data") as Map<*, *>?
                if (dataMap != null) {
                    val trending = dataMap["trending"] as Map<*, *>?
                    @Suppress("UNCHECKED_CAST")
                    val data = trending!!["list"] as List<Map<String, Any>>?
                    return IntStream.range(0, min(data!!.size.toDouble(), 10.0).toInt())
                        .mapToObj { i: Int -> "${i + 1}、${data[i]["keyword"]}" }
                        .collect(Collectors.joining("<br/>"))
                }
            } catch (e: Exception) {
                ConsoleUtils.printErrorLog(e)
            }
            return "操作失败，请查看系统日志"
        }
}
package com.server.handsock.utils
import org.slf4j.LoggerFactory
object ConsoleUtils {
    private val logger = LoggerFactory.getLogger("HandSock-Server")
    fun printErrorLog(content: Any) {
        logger.error(content.toString())
    }
    fun printInfoLog(content: Any) {
        logger.info(content.toString())
    }
    fun printWarnLog(content: Any) {
        logger.warn(content.toString())
    }
    fun printSuccessLog(content: Any) {
        logger.info(content.toString())
    }
}
package com.server.handsock.sockets
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.corundumstudio.socketio.SocketIOServer
import com.server.handsock.sockets.eventer.OnlineEvent
import com.server.handsock.sockets.listener.*
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
class SocketIOListener(
    private val onlineEvent: OnlineEvent,
    private val adminListener: AdminListener,
    private val checkListener: CheckListener,
    private val clientListener: ClientListener,
    private val searchListener: SearchListener,
    private val sendingListener: SendingListener,
    private val userAuthListener: UserAuthListener,
    private val sysConfigListener: SysConfigListener,
    private val userReportListener: UserReportListener,
    private val userUpdateListener: UserUpdateListener
) {
    fun addServerEventListener(server: SocketIOServer) {
        server.addConnectListener {
            onlineEvent.sendUserConnect(
                client = it,
                server = server
            )
        }
        server.addDisconnectListener {
            onlineEvent.sendUserDisconnect(
                client = it,
                server = server
            )
        }
        server.addEventListener("[ONLINE:LOGIN]", Map::class.java) { client: SocketIOClient?, data: Map<*, *>?, ackSender: AckRequest ->
            ackSender.sendAckData(java.util.Map.of("code", 200))
            @Suppress("UNCHECKED_CAST")
            val typedData = data as Map<String, Any>?
            onlineEvent.sendUserOnlineLogin(server, client!!, typedData!!)
        }
        try {
            adminListener.addEventListener()
            clientListener.addEventListener()
            searchListener.addEventListener()
            userAuthListener.addEventListener()
            sysConfigListener.addEventListener()
            userUpdateListener.addEventListener()
            userReportListener.addEventListener()
            checkListener.addEventListener(HandUtils)
            sendingListener.addEventListener(HandUtils)
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.sockets.handler.UserUpdateHandler;
import com.server.handsock.utils.GlobalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service
public class UserUpdateListener {
    private final SocketIOServer server;
    private final UserUpdateHandler userUpdateHandler;
    @Autowired
    public UserUpdateListener(UserUpdateHandler userUpdateHandler) {
        this.server = GlobalService.INSTANCE.getSocketIOServer();
        this.userUpdateHandler = userUpdateHandler;
    }
    public void addEventListener() {
        server.addEventListener("[EDIT:USER:NICK]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userUpdateHandler.handleEditUserInfo(client, typedData, ackSender, "USER:NICK");
        });
        server.addEventListener("[EDIT:USER:AVATAR]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userUpdateHandler.handleEditUserInfo(client, typedData, ackSender, "USER:AVATAR");
        });
        server.addEventListener("[EDIT:USER:USERNAME]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userUpdateHandler.handleEditUserInfo(client, typedData, ackSender, "USER:USERNAME");
        });
        server.addEventListener("[EDIT:USER:PASSWORD]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userUpdateHandler.handleEditUserInfo(client, typedData, ackSender, "USER:PASSWORD");
        });
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.sockets.handler.UserReportHandler;
import com.server.handsock.utils.GlobalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service
public class UserReportListener {
    private final SocketIOServer server;
    private final UserReportHandler userReportHandler;
    @Autowired
    public UserReportListener(UserReportHandler userReportHandler) {
        this.userReportHandler = userReportHandler;
        this.server = GlobalService.INSTANCE.getSocketIOServer();
    }
    public void addEventListener() {
        server.addEventListener("[REPORT:USER]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userReportHandler.handleReport(client, typedData, ackSender);
        });
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.sockets.handler.UserAuthHandler;
import com.server.handsock.utils.GlobalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service
public class UserAuthListener {
    private final SocketIOServer server;
    private final UserAuthHandler userAuthHandler;
    @Autowired
    public UserAuthListener(UserAuthHandler userAuthHandler) {
        this.userAuthHandler = userAuthHandler;
        this.server = GlobalService.INSTANCE.getSocketIOServer();
    }
    public void addEventListener() {
        server.addEventListener("[USER:LOGIN]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userAuthHandler.handleUserLogin(client, typedData, ackSender);
        });
        server.addEventListener("[USER:LOGOUT]", Map.class, (client, data, ackSender) -> {
            userAuthHandler.handleUserLogout(client, server, ackSender);
        });
        server.addEventListener("[USER:REGISTER]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userAuthHandler.handleUserRegister(client, typedData, ackSender);
        });
        server.addEventListener("[USER:SCAN:LOGIN]", Map.class, (client, data, ackSender) -> {
            userAuthHandler.handleUserScanLogin(client, ackSender);
        });
        server.addEventListener("[USER:SCAN:LOGIN:STATUS]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            userAuthHandler.handleGetScanLoginStatus(client, typedData, ackSender);
        });
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.sockets.handler.SysConfigHandler;
import com.server.handsock.utils.GlobalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service
public class SysConfigListener {
    private final SocketIOServer server;
    private final SysConfigHandler sysConfigHandler;
    @Autowired
    public SysConfigListener(SysConfigHandler sysConfigHandler) {
        this.sysConfigHandler = sysConfigHandler;
        this.server = GlobalService.INSTANCE.getSocketIOServer();
    }
    public void addEventListener() {
        server.addEventListener("[GET:SYSTEM:CONFIG]", Map.class, (client, data, ackSender) -> {
            sysConfigHandler.handleGetAllSystemConfig(client, ackSender);
        });
        server.addEventListener("[GET:SYSTEM:PLAYLIST]", Map.class, (client, data, ackSender) -> {
            sysConfigHandler.handleGetSystemPlaylist(client, ackSender);
        });
        server.addEventListener("[SET:SYSTEM:CONFIG:TABOO]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            sysConfigHandler.handleSetSystemTaboo(client, typedData, ackSender);
        });
        server.addEventListener("[SET:SYSTEM:CONFIG:UPLOAD]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            sysConfigHandler.handleSetSystemUpload(client, typedData, ackSender);
        });
        server.addEventListener("[SET:SYSTEM:CONFIG:REGISTER]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            sysConfigHandler.handleSetSystemRegister(client, typedData, ackSender);
        });
        server.addEventListener("[SET:SYSTEM:CONFIG:VALUE]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            sysConfigHandler.handleSetSystemConfigValue(client, typedData, ackSender);
        });
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.props.AiProp;
import com.server.handsock.services.ClientService;
import com.server.handsock.sockets.eventer.RobotSender;
import com.server.handsock.sockets.handler.AIChatHandler;
import com.server.handsock.sockets.handler.SendingHandler;
import com.server.handsock.utils.GlobalService;
import com.server.handsock.utils.HandUtils;
import lombok.Getter;
import lombok.Setter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service @Getter @Setter
public class SendingListener {
    private final SocketIOServer server;
    private final RobotSender robotSender;
    private final AiProp aiProp;
    private final AIChatHandler aiChatHandler;
    private final ClientService clientService;
    private final SendingHandler sendingHandler;
    @Autowired
    public SendingListener(AiProp aiProp, SendingHandler sendingHandler, ClientService clientService, RobotSender robotSender, AIChatHandler aiChatHandler) {
        this.robotSender = robotSender;
        this.aiProp = aiProp;
        this.clientService = clientService;
        this.aiChatHandler = aiChatHandler;
        this.sendingHandler = sendingHandler;
        this.server = GlobalService.INSTANCE.getSocketIOServer();
    }
    public void addEventListener(HandUtils handUtils) {
        server.addEventListener("[SEND:MESSAGE]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            sendingHandler.handleSendMessage(server, client, typedData, ackSender);
        });
        server.addEventInterceptor((client, eventName, args, ackRequest) -> {
            try {
                Object dataEvent = !args.isEmpty() ? args.get(0) : null;
                if (eventName.equals("[SEND:MESSAGE]") && dataEvent != null)
                    robotSender.handleSendMessageOnBot(dataEvent, client, ackRequest);
            } catch (Exception e) {
                ackRequest.sendAckData(handUtils.printErrorLog(e));
            }
        });
        server.addEventListener("[SEND:AI:CHAT:MESSAGE]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            aiChatHandler.handleAIChatMessage(client, typedData, ackSender, aiProp);
        });
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.services.ClientService;
import com.server.handsock.sockets.handler.SearchHandler;
import com.server.handsock.utils.GlobalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service
public class SearchListener {
    private final SocketIOServer server;
    private final SearchHandler searchHandler;
    private final ClientService clientService;
    @Autowired
    public SearchListener(SearchHandler searchHandler, ClientService clientService) {
        this.searchHandler = searchHandler;
        this.clientService = clientService;
        this.server = GlobalService.INSTANCE.getSocketIOServer();
    }
    public void addEventListener() {
        server.addEventListener("[SEARCH:GROUP]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            searchHandler.handleSearchGroup(typedData, ackSender);
        });
        server.addEventListener("[SEARCH:USER:ALL]", Map.class, (client, data, ackSender) -> {
            searchHandler.handleSearchAllUser(ackSender);
        });
        server.addEventListener("[SEARCH:GROUP:ALL]", Map.class, (client, data, ackSender) -> {
            searchHandler.handleSearchAllGroup(ackSender);
        });
        server.addEventListener("[SEARCH:HISTORY:ALL]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            searchHandler.handleSearchAllHistory(typedData, ackSender);
            client.joinRoom(String.valueOf(clientService.getRemoteGID(client)));
        });
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.sockets.handler.ClientHandler;
import com.server.handsock.utils.GlobalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service
public class ClientListener {
    private final SocketIOServer server;
    private final ClientHandler clientHandler;
    @Autowired
    public ClientListener(ClientHandler clientHandler)  {
        this.clientHandler = clientHandler;
        this.server = GlobalService.INSTANCE.getSocketIOServer();
    }
    public void addEventListener() {
        server.addEventListener("[CLIENT:INIT]", Map.class, (client, data, ackRequest) -> clientHandler.handleClientInit(client, ackRequest));
    }
}
package com.server.handsock.sockets.listener;
import com.server.handsock.props.HandProp;
import com.server.handsock.utils.GlobalService;
import com.server.handsock.utils.HandUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
import java.util.Objects;
@Service
public class CheckListener {
    private final HandProp handProp;
    @Autowired
    public CheckListener(HandProp handProp) {
        this.handProp = handProp;
    }
    public void addEventListener(HandUtils handUtils) {
        Objects.requireNonNull(GlobalService.INSTANCE.getSocketIOServer()).addEventListener("[CLIENT:CHECK]", Map.class, (client, data, ackSender) -> {
            if (data.get("version").equals(handProp.getAppVersion())) {
                ackSender.sendAckData(handUtils.handleResultByCode(200, null, "服务正常"));
            } else ackSender.sendAckData(handUtils.handleResultByCode(500, null, "服务异常"));
        });
    }
}
package com.server.handsock.sockets.listener;
import com.corundumstudio.socketio.SocketIOServer;
import com.server.handsock.sockets.eventer.OnlineEvent;
import com.server.handsock.sockets.handler.AdminHandler;
import com.server.handsock.utils.GlobalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.Map;
@Service
public class AdminListener {
    private final OnlineEvent onlineEvent;
    private final SocketIOServer server;
    private final AdminHandler adminHandler;
    @Autowired
    public AdminListener(AdminHandler adminHandler, OnlineEvent onlineEvent) {
        this.onlineEvent = onlineEvent;
        this.adminHandler = adminHandler;
        this.server = GlobalService.INSTANCE.getSocketIOServer();
    }
    public void addEventListener()  {
        server.addEventListener("[RE:FORCE:LOAD]", Map.class, (client, data, ackSender) -> {
            adminHandler.forceReloadClient(server, client, ackSender, "[RE:FORCE:LOAD]", onlineEvent);
        });
        server.addEventListener("[RE:FORCE:CONNECT]", Map.class, (client, data, ackSender) -> {
            adminHandler.forceReloadClient(server, client, ackSender, "[RE:FORCE:CONNECT]", onlineEvent);
        });
        server.addEventListener("[RE:HISTORY:CLEAR]", Map.class, (client, data, ackSender) -> {
            adminHandler.forceReloadClient(server, client, ackSender, "[RE:HISTORY:CLEAR]", onlineEvent);
        });
        server.addEventListener("[DEL:ADMIN:USER]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteUser", "uid", null);
        });
        server.addEventListener("[DEL:ADMIN:CHAT]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteChat", "sid", null);
        });
        server.addEventListener("[DEL:ADMIN:REPO]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteRepo", "rid", null);
        });
        server.addEventListener("[DEL:ADMIN:CHAN]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteChan", "gid", null);
        });
        server.addEventListener("[DEL:ADMIN:BANNER]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteBanner", "bid", null);
        });
        server.addEventListener("[DEL:ADMIN:NOTICE]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteNotice", "nid", null);
        });
        server.addEventListener("[DEL:ADMIN:UPLOAD]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteUpload", "fid", null);
        });
        server.addEventListener("[DEL:ADMIN:SYSTEM:LOGS]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "deleteSystemLogs", "", null);
        });
        server.addEventListener("[ADD:ADMIN:CHAN]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "createChan", "", null);
        });
        server.addEventListener("[ADD:ADMIN:BANNER]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "createBanner", "", null);
        });
        server.addEventListener("[ADD:ADMIN:NOTICE]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "createNotice", "", null);
        });
        server.addEventListener("[GET:ADMIN:DASH:DATA]", Map.class, (client, data, ackSender) -> {
            adminHandler.getDashboardData(client, ackSender);
        });
        server.addEventListener("[GET:ADMIN:USER:LIST]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getUserList", "", null);
        });
        server.addEventListener("[GET:ADMIN:BANNER:LIST]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getBannerList", "", null);
        });
        server.addEventListener("[GET:ADMIN:NOTICE:LIST]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getNoticeList", "", null);
        });
        server.addEventListener("[GET:ADMIN:CHAT:LIST]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getChatList", "", null);
        });
        server.addEventListener("[GET:ADMIN:CHAN:LIST]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getChanList", "", null);
        });
        server.addEventListener("[GET:ADMIN:REPO:LIST]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getRepoList", "", null);
        });
        server.addEventListener("[GET:ADMIN:UPLOAD:LIST]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getUploadList", "", null);
        });
        server.addEventListener("[GET:ADMIN:CHAT:CONTENT]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getChatContent", "sid", null);
        });
        server.addEventListener("[GET:ADMIN:SYSTEM:LOGS]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "getSystemLogs", "", null);
        });
        server.addEventListener("[SET:ADMIN:CHAN:INFO]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateChanInfo", "", null);
        });
        server.addEventListener("[SET:ADMIN:BANNER:INFO]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateBannerInfo", "", null);
        });
        server.addEventListener("[SET:ADMIN:NOTICE:INFO]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateNoticeInfo", "", null);
        });
        server.addEventListener("[SET:ADMIN:USER:INFO]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateUserInfo", "", null);
        });
        server.addEventListener("[SET:ADMIN:USER:PASSWORD]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateUserPassword", "uid", "password");
        });
        server.addEventListener("[SET:ADMIN:CHAN:OPEN:STATUS]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateChanOpenStatus", "gid", "status");
        });
        server.addEventListener("[SET:ADMIN:CHAN:ACTIVE:STATUS]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateChanActiveStatus", "gid", "status");
        });
        server.addEventListener("[SET:ADMIN:USER:TABOO:STATUS]", Map.class, (client, data, ackSender) -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> typedData = (Map<String, Object>) data;
            adminHandler.handleAdminRequest(client, typedData, ackSender, "updateUserTabooStatus", "uid", "status");
        });
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class UserUpdateHandler @Autowired constructor(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val clientUserService: ClientUserService
) {
    fun handleEditUserInfo(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest, editType: String?) {
        ackSender.sendAckData(authService.validClientStatusBySocket(client) {
            try {
                when (editType) {
                    "USER:NICK" -> clientUserService.editForNick(
                        clientService.getRemoteUID(client), clientService.getClientData(data, "nick")
                    )
                    "USER:AVATAR" -> clientUserService.editForAvatar(
                        clientService.getRemoteUID(client),
                        clientService.getClientData(data, "path")
                    )
                    "USER:USERNAME" -> clientUserService.editForUserName(
                        clientService.getRemoteUID(client),
                        clientService.getClientData(data, "username")
                    )
                    "USER:PASSWORD" -> clientUserService.editForPassword(
                        clientService.getRemoteUID(client),
                        clientService.getClientData(data, "password")
                    )
                    else -> HandUtils.handleResultByCode(400, null, "无效的编辑类型")
                }
            } catch (e: Exception) {
                HandUtils.printErrorLog(e)
            }
        })
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.server.handsock.clients.service.ClientReportService
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import org.springframework.stereotype.Service
@Service
class UserReportHandler(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val clientReportService: ClientReportService
) {
    fun handleReport(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validClientStatusBySocket(client) {
            clientReportService.addReport(
                clientService.getClientData(data, "sid"),
                clientService.getRemoteUID(client).toString().toLong(),
                clientService.getClientData(data, "reported_id").toLong(),
                clientService.getClientData(data, "reason")
            )
        })
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.corundumstudio.socketio.SocketIOServer
import com.server.handsock.admin.service.ServerSystemService
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import com.server.handsock.services.TokenService
import com.server.handsock.sockets.eventer.OnlineEvent
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.IDGenerator
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class UserAuthHandler @Autowired constructor(
    private val authService: AuthService,
    private val onlineEvent: OnlineEvent,
    private val tokenService: TokenService,
    private val clientService: ClientService,
    private val clientUserService: ClientUserService,
    private val serverSystemService: ServerSystemService
) {
    fun handleUserLogin(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        try {
            if (!onlineEvent.checkClient(HandUtils.encodeStringToMD5(client.sessionId.toString()))) {
                ackSender.sendAckData(HandUtils.handleResultByCode(403, null, "禁止访问"))
            } else {
                ackSender.sendAckData(
                    clientUserService.loginUser(
                        address = clientService.getRemoteAddress(client),
                        username = clientService.getClientData(data, "username"),
                        password = clientService.getClientData(data, "password")
                    )
                )
            }
        } catch (e: Exception) {
            ackSender.sendAckData(HandUtils.printErrorLog(e))
        }
    }
    fun handleUserLogout(client: SocketIOClient, server: SocketIOServer?, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validClientStatusBySocket(client) {
            if (!onlineEvent.checkClient(HandUtils.encodeStringToMD5(client.sessionId.toString()))) {
                HandUtils.handleResultByCode(403, null, "禁止访问")
            } else {
                onlineEvent.sendUserDisconnect(server!!, client)
                ConsoleUtils.printInfoLog(
                    "User Logout ${clientService.getRemoteAddress(client)} ${clientService.getRemoteUID(client)}"
                )
            }
        })
    }
    fun handleUserRegister(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        try {
            if (!onlineEvent.checkClient(HandUtils.encodeStringToMD5(client.sessionId.toString()))) {
                ackSender.sendAckData(HandUtils.handleResultByCode(403, null, "禁止访问"))
            } else {
                if (serverSystemService.getSystemKeyStatus("register")) {
                    val result = clientUserService.registerUser(
                        clientService.getClientData(data, "username"),
                        clientService.getClientData(data, "password"),
                        clientService.getRemoteAddress(client)
                    )
                    ackSender.sendAckData(result)
                } else ackSender.sendAckData(HandUtils.handleResultByCode(402, null, "当前禁止注册"))
            }
        } catch (e: Exception) {
            ackSender.sendAckData(HandUtils.printErrorLog(e))
        }
    }
    fun handleUserScanLogin(client: SocketIOClient, ackSender: AckRequest) {
        try {
            if (!onlineEvent.checkClient(HandUtils.encodeStringToMD5(client.sessionId.toString()))) {
                ackSender.sendAckData(HandUtils.handleResultByCode(403, null, "禁止访问"))
            } else {
                val qid = IDGenerator.generateUniqueId()
                val content = mapOf(
                    "qid" to qid,
                    "type" to "login",
                    "platform" to "H5"
                )
                tokenService.setScanStatus(qid, 0)
                /*QrcodeUtils.generateQrcode(content.toString())*/
                ackSender.sendAckData(HandUtils.handleResultByCode(200, content, "获取成功"))
            }
        } catch (e: Exception) {
            ackSender.sendAckData(HandUtils.printErrorLog(e))
        }
    }
    fun handleGetScanLoginStatus(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        try {
            if (!onlineEvent.checkClient(HandUtils.encodeStringToMD5(client.sessionId.toString()))) {
                ackSender.sendAckData(HandUtils.handleResultByCode(403, null, "禁止访问"))
            } else {
                val qid = clientService.getClientData(data, "qid")
                ackSender.sendAckData(clientUserService.getUserQrcodeScanStatus(
                    qid = qid,
                    address = clientService.getRemoteAddress(client)
                ))
            }
        } catch (e: Exception) {
            ackSender.sendAckData(HandUtils.printErrorLog(e))
        }
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.server.handsock.admin.service.ServerSystemService
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class SysConfigHandler @Autowired constructor(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val serverSystemService: ServerSystemService
) {
    fun handleSetSystemTaboo(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validAdminStatusBySocket(client) {
            val value = clientService.getClientData(data, "value")
            serverSystemService.setSystemTabooStatus(value)
        })
    }
    fun handleSetSystemUpload(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validAdminStatusBySocket(client) {
            val value = clientService.getClientData(data, "value")
            serverSystemService.setSystemUploadStatus(value)
        })
    }
    fun handleSetSystemRegister(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validAdminStatusBySocket(client) {
            val value = clientService.getClientData(data, "value")
            serverSystemService.setSystemRegisterStatus(value)
        })
    }
    fun handleSetSystemConfigValue(client: SocketIOClient, data: Map<String?, Any>, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validAdminStatusBySocket(client) {
            val name = clientService.getClientData(data, "name")
            val value = clientService.getClientData(data, "value")
            serverSystemService.setSystemConfigValue(
                name = name,
                value = value
            )
        })
    }
    fun handleGetSystemPlaylist(client: SocketIOClient, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validAdminStatusBySocket(client) {
            serverSystemService.getSystemKeyConfig("playlist")
        })
    }
    fun handleGetAllSystemConfig(client: SocketIOClient, ackSender: AckRequest) {
        ackSender.sendAckData(authService.validAdminStatusBySocket(client) {
            serverSystemService.allSystemConfig
        })
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.corundumstudio.socketio.SocketIOServer
import com.server.handsock.clients.service.ClientChatService
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.HandUtils
import lombok.Getter
import lombok.Setter
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Getter @Setter @Service
class SendingHandler @Autowired constructor(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val clientChatService: ClientChatService,
) {
    fun handleSendMessage(server: SocketIOServer, client: SocketIOClient, data: Map<String?, Any>, ackRequest: AckRequest) {
        authService.validChatMessageStatusBySocket(
            data = data,
            client = client,
            ackRequest = ackRequest,
            call = {
                try {
                    val content = HandUtils.stripHtmlTagsForString(clientService.getClientData(data, CONTENT_KEY))
                    val result = clientChatService.insertChatMessage(
                        clientService.getClientData(data, TYPE_KEY),
                        clientService.getRemoteUID(client),
                        clientService.getRemoteGID(client),
                        clientService.getRemoteAddress(client),
                        content
                    )
                    @Suppress("UNCHECKED_CAST")
                    sendAckData(ackRequest, result as Map<String?, Any>)
                    if (isSuccessResult(result)) HandUtils.sendRoomMessage(
                        client = client,
                        server = server,
                        event = "[MESSAGE]",
                        content = result["data"]
                    )
                } catch (e: Exception) {
                    ackRequest.sendAckData(HandUtils.printErrorLog(e))
                }
            }
        )
    }
    private fun isSuccessResult(result: Map<String?, Any>): Boolean {
        return clientService.getClientData(result, CODE_KEY).toInt() == 200
    }
    private fun sendAckData(ackRequest: AckRequest, result: Map<String?, Any>) {
        ackRequest.sendAckData(result)
    }
    companion object {
        private const val TYPE_KEY = "type"
        private const val CODE_KEY = "code"
        private const val CONTENT_KEY = "content"
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.server.handsock.clients.service.ClientChannelService
import com.server.handsock.clients.service.ClientChatService
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class SearchHandler @Autowired constructor(
    private val clientService: ClientService,
    private val clientChatService: ClientChatService,
    private val clientChannelService: ClientChannelService,
    private val clientUserService: ClientUserService
) {
    fun handleSearchGroup(data: Map<String?, Any>, ackRequest: AckRequest) {
        try {
            ackRequest.sendAckData(
                clientChannelService.searchGroupByGid(
                    clientService.getClientData(data, "gid").toLong()
                )
            )
        } catch (e: Exception) {
            ackRequest.sendAckData(HandUtils.printErrorLog(e))
        }
    }
    fun handleSearchAllGroup(ackRequest: AckRequest) {
        try {
            ackRequest.sendAckData(clientChannelService.searchAllGroup())
        } catch (e: Exception) {
            ackRequest.sendAckData(HandUtils.printErrorLog(e))
        }
    }
    fun handleSearchAllUser(ackRequest: AckRequest) {
        try {
            ackRequest.sendAckData(clientUserService.queryAllUser())
        } catch (e: Exception) {
            ackRequest.sendAckData(HandUtils.printErrorLog(e))
        }
    }
    fun handleSearchAllHistory(data: Map<String?, Any>, ackRequest: AckRequest) {
        try {
            ackRequest.sendAckData(
                clientChatService.searchAllChatHistory(
                    clientService.getClientData(data, "gid").toLong()
                )
            )
        } catch (e: Exception) {
            ackRequest.sendAckData(HandUtils.printErrorLog(e))
        }
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ClientHandler @Autowired constructor(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val clientUserService: ClientUserService
) {
    fun handleClientInit(client: SocketIOClient, ackRequest: AckRequest) {
        ackRequest.sendAckData(authService.validClientStatusBySocket(client) {
            val result: MutableMap<String, Any> = HashMap()
            result["userinfo"] = clientUserService.queryUserInfo(clientService.getRemoteUID(client))
            HandUtils.handleResultByCode(200, result, "获取成功")
        })
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.fasterxml.jackson.databind.ObjectMapper
import com.server.handsock.clients.man.ClientChatManage
import com.server.handsock.clients.mod.ClientChatModel
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.props.AiProp
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.IDGenerator
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpHeaders
import org.springframework.stereotype.Service
import org.springframework.web.reactive.function.client.WebClient
import java.util.*
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
@Service
class AIChatHandler @Autowired constructor(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val clientUserService: ClientUserService,
) {
    private val objectMapper = ObjectMapper()
    private val sendExecutor: ExecutorService = Executors.newFixedThreadPool(4)
    fun handleAIChatMessage(client: SocketIOClient, data: Map<String?, Any>, ackRequest: AckRequest, aiProp: AiProp) {
        authService.validChatMessageStatusBySocket(
            data = data,
            client = client,
            ackRequest = ackRequest,
            call = {
                try {
                    val clientChannelDao = ClientChatModel()
                    val clientChatManage = ClientChatManage(HandUtils, ConsoleUtils, IDGenerator)
                    val content = HandUtils.stripHtmlTagsForString(clientService.getClientData(data, CONTENT_KEY))
                    val userResult = clientChatManage.insertChatMessage(clientChannelDao, "text", clientService.getRemoteUID(client), clientService.getRemoteGID(client), clientService.getRemoteAddress(client), content)
                    ackRequest.sendAckData(HandUtils.handleResultByCode(200, userResult, "请求成功"))
                    Thread.sleep(800)
                    val robotUser = clientUserService.robotInnerStatus
                    val hasAiAuth = clientService.hasAiAuthorization(client)
                    val message = if (hasAiAuth) REQUEST_STATUS else DEFAULT_MESSAGE
                    val aiResult = clientChatManage.insertChatMessage(clientChannelDao, "text", robotUser!!.uid, clientService.getRemoteGID(client), "none", message)
                    sendEventWithResult(client, aiResult)
                    if (hasAiAuth) sendAIRequest(
                        client = client,
                        userContent = content,
                        aiProp = aiProp,
                        sid = aiResult["sid"].toString(),
                        uid = clientService.getRemoteUID(client)
                    )
                } catch (e: Exception) {
                    ackRequest.sendAckData(HandUtils.printErrorLog(e))
                }
            }
        )
    }
    private fun sendEventWithResult(client: SocketIOClient, aiResult: Map<String, Any>) {
        client.sendEvent(
            "[AI:CHAT:CREATE:MESSAGE]",
            HandUtils.handleResultByCode(200, object : HashMap<String?, Any?>() {
                init {
                    put("event", "CREATE-MESSAGE")
                    put("result", aiResult)
                }
            }, "请求成功")
        )
    }
    private fun sendAIRequest(client: SocketIOClient, sid: String, uid: Long, userContent: String?, aiProp: AiProp) {
        val webClient = Objects.requireNonNull(aiProp.url)?.let {
            WebClient.builder()
                .baseUrl(it)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, "application/json")
                .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + aiProp.token)
                .build()
        }
        userMessageHistory.computeIfAbsent(uid) { ArrayList() }.add(userContent)
        val roleString = "{\"role\": \"system\",\"content\": \"你是HandSock聊天室的高效AI助手，由HandSock开发团队深度优化，专注精准理解与简洁表达。回复严格≤150字，用<think>快速梳理核心逻辑后，先输出<br/>后再输出自然口语化答案。”\"}"
        val roleStringBuilder = StringBuilder(roleString)
        for (msg in userMessageHistory[uid]!!) roleStringBuilder.append(",{\"role\": \"user\",\"name\": \"").append(uid).append("\",\"content\": \"").append(msg).append("\"}")
        val roleStringWithHistory = roleStringBuilder.toString()
        ConsoleUtils.printInfoLog(roleStringWithHistory)
        val requestBody = """{
            "model": "${aiProp.model}",
            "messages": [
                $roleStringWithHistory
            ],
            "response_format": {
                "type": "text"
            },
            "stream": true
        }"""
        if (webClient == null) return
        aiProp.path?.let {
            webClient.post()
                .uri(it)
                .bodyValue(requestBody)
                .retrieve()
                .bodyToFlux(String::class.java)
        }?.subscribe(
            { line: String? -> handleResponseLine(client, sid, line) },
            { error: Throwable ->
                ConsoleUtils.printErrorLog(error)
                client.sendEvent(
                    "[AI:CHAT:CREATE:MESSAGE]",
                    HandUtils.handleResultByCode(200, object : HashMap<String?, Any?>() {
                        init {
                            put("event", "PUSH-STREAM")
                            put("eventId", sid)
                            put("content", "请求失败，请查看日志")
                        }
                    }, "请求成功")
                )
            }, {
                ConsoleUtils.printInfoLog("AI Request Complete $sid")
            }
        )
    }
    private fun handleResponseLine(client: SocketIOClient, sid: String, line: String?) {
        if (line == null || line.trim { it <= ' ' }.isEmpty()) return
        if ("[DONE]" == line.trim { it <= ' ' }) return
        try {
            val contentNode = objectMapper.readTree(line).path("choices")[0].path("delta").path("content")
            if (contentNode.isMissingNode || contentNode.asText().isEmpty()) return
            val eventData: MutableMap<String, Any> = HashMap()
            eventData["event"] = "PUSH-STREAM"
            eventData["eventId"] = sid
            eventData["content"] = contentNode.asText()
            sendExecutor.execute {
                client.sendEvent("[AI:CHAT:CREATE:MESSAGE]", HandUtils.handleResultByCode(200, eventData, "请求成功"))
            }
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
        }
    }
    companion object {
        private const val CONTENT_KEY = "content"
        private const val REQUEST_STATUS = "正在请求中"
        private val userMessageHistory: MutableMap<Long, MutableList<String?>> = ConcurrentHashMap()
        private const val DEFAULT_MESSAGE = "暂无AI能力相关权限，请前往任意非AI频道发送【handsock apply-ai】以开启AI能力"
    }
}
package com.server.handsock.sockets.handler
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.corundumstudio.socketio.SocketIOServer
import com.server.handsock.admin.service.*
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import com.server.handsock.sockets.eventer.OnlineEvent
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class AdminHandler @Autowired constructor(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val serverLogService: ServerLogService,
    private val serverUserService: ServerUserService,
    private val serverChatService: ServerChatService,
    private val serverDashService: ServerDashService,
    private val serverNoticeService: ServerNoticeService,
    private val serverUploadService: ServerUploadService,
    private val serverReportService: ServerReportService,
    private val serverBannerService: ServerBannerService,
    private val serverChannelService: ServerChannelService
) {
    fun handleAdminRequest(client: SocketIOClient, data: Map<String?, Any>?, ackSender: AckRequest, action: String?, uidKey: String, valueKey: String?) {
        ackSender.sendAckData(authService.validAdminStatusBySocket(client) {
            try {
                val value = if (data != null) getClientData(data, uidKey) else "none"
                val valueData = if (data != null && valueKey != null) getClientData(data, valueKey) else null
                val actionMap = mutableMapOf<String, () -> Any>().apply {
                    // Admin Delete
                    put("deleteUser") { deleteUser(value) }
                    put("deleteChan") { deleteChan(value) }
                    put("deleteChat") { deleteChat(value) }
                    put("deleteRepo") { deleteRepo(value) }
                    put("deleteBanner") { deleteBanner(value) }
                    put("deleteNotice") { deleteNotice(value) }
                    put("deleteUpload") { deleteUpload(value) }
                    put("deleteSystemLogs") { serverLogService.deleteSystemLogs() }
                    // Admin Create
                    put("createChan") { createChan(data!!) }
                    put("createBanner") { createBanner(data!!) }
                    put("createNotice") { createNotice(data!!) }
                    put("updateChanInfo") { updateChanInfo(data) }
                    put("updateBannerInfo") { updateBannerInfo(data) }
                    put("updateNoticeInfo") { updateNoticeInfo(data) }
                    put("updateUserInfo") { updateUserInfo(data) }
                    // Admin Get
                    put("getUserList") { getUserList(data) }
                    put("getChatList") { getChatList(data) }
                    put("getChanList") { getChanList(data) }
                    put("getBannerList") { getBannerList(data) }
                    put("getNoticeList") { getNoticeList(data) }
                    put("getRepoList") { getRepoList(data) }
                    put("getSystemLogs") { serverLogService.systemLogs }
                    put("getUploadList") { getUploadList(data) }
                    put("getChatContent") { getChatContent(value) }
                }
                if (valueData != null) {
                    actionMap.apply {
                        put("updateUserPassword") { updateUserPassword(value, valueData) }
                        put("updateChanOpenStatus") { updateChanOpenStatus(value, valueData) }
                        put("updateChanActiveStatus") { updateChanActiveStatus(value, valueData) }
                        put("updateUserTabooStatus") { updateUserTabooStatus(value, valueData) }
                    }
                }
                action?.let { actionKey ->
                    actionMap[actionKey]?.let { handler -> handler()
                    } ?: HandUtils.handleResultByCode(400, null, "未知操作")
                } ?: HandUtils.handleResultByCode(400, null, "操作类型未指定")
            } catch (e: Exception) {
                HandUtils.printErrorLog(e)
            }
        })
    }
    private fun getClientData(data: Map<String?, Any>, key: String): Any? {
        return data[key]
    }
    private fun deleteUser(value: Any?): Any {
        return serverUserService.deleteUser(value.toString().toLong())
    }
    private fun deleteChan(value: Any?): Any {
        return serverChannelService.deleteChan(value.toString().toLong())
    }
    private fun deleteRepo(value: Any?): Any {
        return serverReportService.deleteReport(value.toString())
    }
    private fun deleteUpload(value: Any?): Any {
        return serverUploadService.deleteUpload(value.toString())
    }
    private fun deleteBanner(value: Any?): Any {
        return serverBannerService.deleteBanner(value.toString().toInt())
    }
    private fun deleteNotice(value: Any?): Any {
        return serverNoticeService.deleteNotice(value.toString().toInt())
    }
    private fun deleteChat(value: Any?): Any {
        return serverChatService.deleteChat(value.toString())
    }
    private fun getChatContent(value: Any?): Any {
        return serverChatService.getChatContent(value.toString())
    }
    private fun handleListRequest(serviceCall: (Int, Int) -> Any, data: Map<String?, Any>?): Any {
        val page = clientService.getClientData(data!!, "page").toInt()
        val limit = clientService.getClientData(data, "limit").toInt()
        return serviceCall(page, limit)
    }
    private fun getUserList(data: Map<String?, Any>?) =
        handleListRequest(serverUserService::getUserList, data)
    private fun getChatList(data: Map<String?, Any>?) =
        handleListRequest(serverChatService::getChatList, data)
    private fun getChanList(data: Map<String?, Any>?) =
        handleListRequest(serverChannelService::getChanList, data)
    private fun getRepoList(data: Map<String?, Any>?) =
        handleListRequest(serverReportService::getReportList, data)
    private fun getBannerList(data: Map<String?, Any>?) =
        handleListRequest(serverBannerService::getBannerList, data)
    private fun getNoticeList(data: Map<String?, Any>?) =
        handleListRequest(serverNoticeService::getNoticeList, data)
    private fun getUploadList(data: Map<String?, Any>?) =
        handleListRequest(serverUploadService::getUploadList, data)
    private fun updateUserPassword(value: Any?, valueData: Any): Any {
        return serverUserService.updateUserPassword(
            uid = value.toString().toLong(),
            password = valueData.toString()
        )
    }
    private fun updateChanOpenStatus(value: Any?, valueData: Any): Any {
        return serverChannelService.updateChanOpenStatus(
            gid = value.toString().toLong(),
            status = valueData.toString().toInt()
        )
    }
    private fun updateChanActiveStatus(value: Any?, valueData: Any): Any {
        return serverChannelService.updateChanActiveStatus(
            gid = value.toString().toLong(),
            status = valueData.toString().toInt()
        )
    }
    private fun updateUserTabooStatus(value: Any?, valueData: Any): Any {
        return serverUserService.updateUserTabooStatus(
            uid = value.toString().toLong(),
            status = valueData.toString()
        )
    }
    private fun createChan(data: Map<String?, Any>): Any {
        return serverChannelService.createChan(
            clientService.getClientData(
                data = data,
                key = "gid"
            ).toLong(),
            clientService.getClientData(
                data = data,
                key = "name"
            ),
            clientService.getClientData(
                data = data,
                key = "avatar"
            ),
            clientService.getClientData(
                data = data,
                key = "notice"
            ),
            clientService.getClientData(
                data = data,
                key = "aiRole"
            ).toBoolean()
        )
    }
    private fun createBanner(data: Map<String?, Any>): Any {
        return serverBannerService.createBanner(
            clientService.getClientData(
                data = data,
                key = "name"
            ),
            clientService.getClientData(
                data = data,
                key = "href"
            ),
            clientService.getClientData(
                data = data,
                key = "image"
            ),
        )
    }
    private fun createNotice(data: Map<String?, Any>): Any {
        return serverNoticeService.createNotice(
            clientService.getClientData(
                data = data,
                key = "title"
            ),
            clientService.getClientData(
                data = data,
                key = "content"
            )
        )
    }
    private fun updateUserInfo(data: Map<String?, Any>?): Any {
        return serverUserService.updateUserInfo(
            clientService.getClientData(data!!, "uid").toLong(),
            clientService.getClientData(
                data = data,
                key = "username"
            ),
            clientService.getClientData(data, "nick"),
            clientService.getClientData(data, "avatar"),
            clientService.getClientData(
                data = data,
                key = "robot"
            ).toBoolean()
        )
    }
    private fun updateChanInfo(data: Map<String?, Any>?): Any {
        return serverChannelService.updateChan(
            clientService.getClientData(
                data = data!!,
                key = "gid"
            ).toLong(),
            clientService.getClientData(
                data, "name"
            ),
            clientService.getClientData(
                data = data,
                key = "avatar"
            ),
            clientService.getClientData(
                data = data,
                key = "notice"
            ),
            clientService.getClientData(
                data, "aiRole"
            ).toBoolean()
        )
    }
    private fun updateBannerInfo(data: Map<String?, Any>?): Any {
        return serverBannerService.updateBanner(
            clientService.getClientData(
                data = data!!,
                key = "bid"
            ).toInt(),
            clientService.getClientData(
                data, "name"
            ),
            clientService.getClientData(
                data = data,
                key = "href"
            ),
            clientService.getClientData(
                data = data,
                key = "image"
            )
        )
    }
    private fun updateNoticeInfo(data: Map<String?, Any>?): Any {
        return serverNoticeService.updateNotice(
            clientService.getClientData(
                data = data!!,
                key = "nid"
            ).toInt(),
            clientService.getClientData(
                data, "title"
            ),
            clientService.getClientData(
                data = data,
                key = "content"
            )
        )
    }
    fun getDashboardData(client: SocketIOClient, ackSender: AckRequest) {
        authService.validClientStatusBySocket(client) {
            ackSender.sendAckData(serverDashService.dashboardData)
        }
    }
    fun forceReloadClient(server: SocketIOServer?, client: SocketIOClient, ackSender: AckRequest, event: String, onlineEvent: OnlineEvent) {
        authService.validClientStatusBySocket(client) {
            if (event == "[RE:HISTORY:CLEAR]") serverChatService.clearAllChatHistory()
            onlineEvent.clearClient()
            HandUtils.sendGlobalMessage(server!!, event, null)
            ackSender.sendAckData(object : HashMap<Any?, Any?>() {
                init {
                    put("code", 200)
                    put("message", "指令已发出")
                }
            })
            ConsoleUtils.printInfoLog("Force Client Event：$event")
        }
    }
}
package com.server.handsock.sockets.eventer
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.corundumstudio.socketio.transport.NamespaceClient
import com.server.handsock.admin.service.ServerSystemService
import com.server.handsock.clients.service.ClientChannelService
import com.server.handsock.clients.service.ClientChatService
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.AuthService
import com.server.handsock.services.CacheService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.RobotUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class RobotSender @Autowired constructor(
    private val robotEvent: RobotEvent,
    private val authService: AuthService,
    private val clientService: ClientService,
    private val clientUserService: ClientUserService,
    private val clientChatService: ClientChatService,
    private val clientChannelService: ClientChannelService,
    private val cacheService: CacheService,
    private val serverSystemService: ServerSystemService
) {
    fun handleSendMessageOnBot(dataEvent: Any, client: NamespaceClient, ackRequest: AckRequest) {
        if (isValidMessage(client)) return
        try {
            @Suppress("UNCHECKED_CAST")
            val data = dataEvent as Map<String?, Any>
            val content = clientService.getClientData(data, "content")
            @Suppress("UNCHECKED_CAST")
            val authToken = client.handshakeData.authToken as Map<String?, Any>
            val robotReturn = robotEvent.handleRobotCommand(client, content)
            if (robotReturn != null) {
                Thread.sleep(800)
                RobotUtils.sendRobotMessage(
                    address = "none",
                    content = robotReturn,
                    clientService = clientService,
                    clientChatService = clientChatService,
                    clientUserService = clientUserService,
                    gid = clientService.getClientData(authToken, "gid").toLong()
                )
            }
        } catch (e: Exception) {
            ackRequest.sendAckData(HandUtils.printErrorLog(e))
        } finally {
            cacheService.writeRedisMessageCache(clientService.getRemoteUID(client))
        }
    }
    private fun isValidMessage(client: SocketIOClient): Boolean {
        return !cacheService.validRedisMessageCache(clientService.getRemoteUID(client))
                || clientUserService.robotInnerStatus == null
                || !clientUserService.getUserInnerStatus(clientService.getRemoteUID(client))
                || !clientChannelService.getChanOpenStatus(clientService.getRemoteGID(client))
                || serverSystemService.getSystemKeyStatus("taboo")
                && !clientService.getIsAdmin(client)
                || clientUserService.getUserTabooStatus(clientService.getRemoteUID(client))
                && !clientService.getIsAdmin(client) || !authService.validClientTokenBySocket(client)
    }
}
package com.server.handsock.sockets.eventer
import com.corundumstudio.socketio.SocketIOClient
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.ExternalFetcher
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class RobotEvent @Autowired constructor(
    private val clientUserService: ClientUserService,
    private val clientService: ClientService
) {
    private val commandList: ArrayList<String?> = object : ArrayList<String?>() {
        init {
            add("handsock help") // 使用帮助
            add("handsock userinfo") // 用户信息
            add("handsock hitokoto") // 获取一言
            add("handsock apply-ai") // 开启权限
            add("handsock weibo-hot") // 微博热搜
            add("handsock bilibili-hot") // Bilibili热搜
        }
    }
    /**
     * 处理机器人发送
     *
     * @return String
     * @apiNote 机器人只能发送字符串消息，可以包含HTML标签，不能包含JS脚本（为了前端安全着想）
     */
    fun handleRobotCommand(client: SocketIOClient?, command: String): String? {
        val uid = clientService.getRemoteUID(client!!) // 获取用户ID
        /*val isAdmin = clientService.getIsAdmin(client) // 判断用户是否是管理员*/
        try {
            if (command == commandList[0]) {
                return ("=======handsock=======<br/>"
                        + "userinfo：用户信息<br/>"
                        + "hitokoto：获取一言<br/>"
                        + "weibo-hot：微博热搜<br/>"
                        + "bilibili-hot：Bilibili热搜<br/>"
                        + "=====================")
            }
            if (command == commandList[1]) {
                try {
                    val clientUserModel = clientUserService.queryUserInfo(uid)
                    return "账号：${clientUserModel.username}<br/>" +
                            "昵称：${clientUserModel.nick}<br/>" +
                            "注册：${clientUserModel.regTime}"
                } catch (e: Exception) {
                    ConsoleUtils.printErrorLog(e)
                    return "操作失败，请查看系统日志"
                }
            }
            if (command == commandList[2]) return ExternalFetcher.hitokoto
            if (command == commandList[3]) {
                return if (!clientService.hasAiAuthorization(client)) {
                    if (clientUserService.setUserAiAuthorization(uid, true)) "已为您开启AI能力" else "操作失败，请查看系统日志"
                } else "你已拥有AI能力，无需重复开启"
            }
            if (command == commandList[4]) return ExternalFetcher.weiboHotSearch
            if (command == commandList[5]) return ExternalFetcher.bilibiliHotSearch
            return null
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
            return null
        }
    }
}
package com.server.handsock.sockets.eventer
import com.corundumstudio.socketio.SocketIOClient
import com.corundumstudio.socketio.SocketIOServer
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import org.springframework.stereotype.Service
import java.util.*
import java.util.concurrent.ConcurrentHashMap
import kotlin.concurrent.Volatile
@Service
class OnlineEvent {
    private val clientSet: MutableSet<String> = ConcurrentHashMap.newKeySet()
    private val userMap = ConcurrentHashMap<Long, UserInfo>()
    private fun getClientUUID(client: SocketIOClient): String {
        return HandUtils.encodeStringToMD5(client.sessionId.toString())
    }
    fun sendUserConnect(server: SocketIOServer, client: SocketIOClient) {
        val uuid = getClientUUID(client)
        if (clientSet.add(uuid)) {
            client.sendEvent("[TOKENS]", Collections.singletonMap("data", uuid))
            sendMessage(server)
        }
    }
    fun sendUserDisconnect(server: SocketIOServer, client: SocketIOClient) {
        val uuid = getClientUUID(client)
        if (clientSet.remove(uuid)) {
            processUserDisconnection(client, uuid)
            sendMessage(server)
        }
    }
    private fun processUserDisconnection(client: SocketIOClient, uuid: String) {
        try {
            val authData = client.handshakeData.authToken as Map<*, *>
            val uidObj = authData["uid"] ?: return
            val uid = uidObj.toString().toLong()
            userMap.computeIfPresent(uid) { _: Long?, userInfo: UserInfo -> if (userInfo.removeUuid(uuid)) return@computeIfPresent null
                userInfo
            }
        } catch (e: NumberFormatException) {
            ConsoleUtils.printErrorLog(e)
        }
    }
    fun sendUserOnlineLogin(server: SocketIOServer, client: SocketIOClient, data: Map<String, Any>) {
        try {
            val uid = extractDataField(data, "uid").toLong()
            val status = extractDataField(data, "status").toInt()
            val platform = Objects.toString(data["platform"], "")
            if (status == 0) {
                handleUserLogout(uid, client)
            } else handleUserLogin(uid, client, platform)
            sendMessage(server)
        } catch (e: IllegalArgumentException) {
            ConsoleUtils.printErrorLog(e)
        }
    }
    private fun extractDataField(data: Map<String, Any>, field: String): String {
        val value = data[field] ?: throw IllegalArgumentException("Missing required field: $field")
        return value.toString()
    }
    private fun handleUserLogout(uid: Long, client: SocketIOClient) {
        userMap.computeIfPresent(uid) { _: Long?, userInfo: UserInfo ->
            userInfo.removeUuid(getClientUUID(client))
            if (userInfo.uuids.isEmpty()) null else userInfo
        }
    }
    private fun handleUserLogin(uid: Long, client: SocketIOClient, platform: String) {
        val uuid = getClientUUID(client)
        userMap.compute(uid) { _: Long?, existingUser: UserInfo? ->
            if (existingUser == null) {
                return@compute UserInfo(uid, uuid, platform)
            } else {
                existingUser.addUuid(uuid)
                existingUser.login = true
                existingUser.platform = platform
                return@compute existingUser
            }
        }
    }
    fun clearClient() {
        userMap.clear()
        clientSet.clear()
    }
    fun checkClient(uuid: String): Boolean {
        return clientSet.contains(uuid)
    }
    private fun sendMessage(server: SocketIOServer) {
        val userData: MutableList<Map<String, Any>> = ArrayList(userMap.size)
        userMap.forEach { (_: Long?, userInfo: UserInfo) -> userData.add(createUserMap(userInfo)) }
        HandUtils.sendGlobalMessage(server, "[ONLINE]",
            Collections.singletonMap<String, List<Map<String, Any>>>("data", userData)
        )
    }
    private fun createUserMap(userInfo: UserInfo): Map<String, Any> {
        val map: MutableMap<String, Any> = HashMap(4)
        map["uid"] = userInfo.uid
        map["uuids"] = ArrayList(userInfo.uuids)
        map["login"] = userInfo.login
        map["platform"] = userInfo.platform
        return map
    }
    private class UserInfo(val uid: Long, uuid: String, platform: String) {
        val uuids: MutableSet<String> = ConcurrentHashMap.newKeySet()
        @Volatile
        var login: Boolean = true
        @Volatile
        var platform: String
        init {
            uuids.add(uuid)
            this.platform = platform
        }
        fun addUuid(uuid: String) {
            uuids.add(uuid)
        }
        fun removeUuid(uuid: String): Boolean {
            uuids.remove(uuid)
            return uuids.isEmpty()
        }
    }
}
package com.server.handsock.services
import com.server.handsock.utils.HandUtils
import org.apache.commons.lang3.RandomStringUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.redis.core.RedisTemplate
import org.springframework.stereotype.Service
import java.nio.charset.StandardCharsets
import java.util.*
import java.util.concurrent.TimeUnit
@Service
class TokenService @Autowired constructor(private val redisTemplate: RedisTemplate<String, String>) {
    fun removeUserToken(uid: Long) {
        val cachedToken = redisTemplate.opsForValue()["handsock-userToken:$uid"]
        if (cachedToken != null) redisTemplate.delete("handsock-userToken:$uid")
    }
    fun generateUserToken(uid: Long, username: String, address: String): String? {
        val cachedToken = redisTemplate.opsForValue()["handsock-userToken:$uid"]
        if (cachedToken != null) return cachedToken // 直接使用原有Token（可实现多端同时在线）
        println(1)
        val nanoTime = System.nanoTime().toString()
        val randomString = RandomStringUtils.randomAlphanumeric(16)
        val formatTime = HandUtils.formatTimeForString("yyyy-MM-dd HH:mm:ss.SSS")
        var token = HandUtils.encodeStringToSHA256(uid.toString() + username + address + nanoTime + randomString + formatTime)
        token = Base64.getEncoder().encodeToString(token.toByteArray(StandardCharsets.UTF_8))
        redisTemplate.opsForValue()["handsock-userToken:$uid", token, 30] = TimeUnit.DAYS
        return token
    }
    fun validUserToken(uid: Long, oldToken: String): Boolean {
        val cachedToken = redisTemplate.opsForValue()["handsock-userToken:$uid"]
        return if (cachedToken != null) {
            cachedToken == oldToken
        } else false
    }
    fun setScanStatus(qid: String, status: Int) {
        redisTemplate.opsForValue()["handsock-scanStatus:$qid", status.toString(), 30] = TimeUnit.SECONDS
    }
    fun removeScanStatus(qid: String) {
        val scanStatus = redisTemplate.opsForValue()["handsock-scanStatus:$qid"]
        if (scanStatus != null) redisTemplate.delete("handsock-scanStatus:$qid")
    }
    fun getScanStatus(qid: String): String? {
        val scanStatus = redisTemplate.opsForValue()["handsock-scanStatus:$qid"]
        return scanStatus
    }
    fun setScanTargetUser(qid: String, uid: String) {
        redisTemplate.opsForValue()["handsock-scanTargetUser:$qid", uid, 45] = TimeUnit.SECONDS
    }
    fun getScanTargetUser(qid: String): String? {
        val targetUser = redisTemplate.opsForValue()["handsock-scanTargetUser:$qid"]
        return targetUser
    }
    fun setOpenApiCache(type: String, address: String) {
        redisTemplate.opsForValue()["handsock-openai-$type:$address", "ok", 3] = TimeUnit.SECONDS
    }
    fun getOpenApiCache(type: String, address: String): Boolean {
        val requestStatus = redisTemplate.opsForValue()["handsock-openai-$type:$address"]
        return requestStatus == null
    }
}
package com.server.handsock.services
import com.corundumstudio.socketio.SocketIOClient
import com.server.handsock.clients.service.ClientUserService
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ClientService @Autowired constructor(
    private val clientUserService: ClientUserService
) {
    // 获取客户端数据
    fun getClientData(data: Map<String?, Any>, key: String?): String {
        return data[key].toString()
    }
    // 判断用户是否是管理员
    fun getIsAdmin(client: SocketIOClient): Boolean {
        return clientUserService.queryUserInfo(getRemoteUID(client)).isAdmin == 1
    }
    // 判断用户是否是拥有AI能力相关权限
    fun hasAiAuthorization(client: SocketIOClient): Boolean {
        return clientUserService.queryUserInfo(getRemoteUID(client)).aiAuth == 1
    }
    // 获取用户uid
    fun getRemoteUID(client: SocketIOClient): Long {
        @Suppress("UNCHECKED_CAST")
        val authToken = client.handshakeData.authToken as Map<String, Any>
        return authToken["uid"].toString().toLong()
    }
    // 获取频道gid
    fun getRemoteGID(client: SocketIOClient): Long {
        @Suppress("UNCHECKED_CAST")
        val authToken = client.handshakeData.authToken as Map<String, Any>
        return authToken["gid"].toString().toLong()
    }
    // 获取客户端IP地址
    fun getRemoteAddress(client: SocketIOClient): String {
        return client.remoteAddress.toString().substring(1)
    }
}
package com.server.handsock.services
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.data.redis.core.RedisTemplate
import org.springframework.stereotype.Service
import java.util.concurrent.TimeUnit
@Service
class CacheService @Autowired constructor(private val redisTemplate: RedisTemplate<String, String>) {
    fun writeRedisMessageCache(uid: Long) {
        redisTemplate.opsForValue()["handsock-msgCache:$uid", "ok", 2] = TimeUnit.SECONDS
    }
    fun writeRedisUploadCache(uid: Long) {
        redisTemplate.opsForValue()["handsock-uploadCache:$uid", "ok", 10] = TimeUnit.SECONDS
    }
    fun validRedisMessageCache(uid: Long): Boolean {
        val cache = redisTemplate.opsForValue()["handsock-msgCache:$uid"]
        return cache == null
    }
    fun validRedisUploadCache(uid: Long): Boolean {
        val cache = redisTemplate.opsForValue()["handsock-uploadCache:$uid"]
        return cache == null
    }
}
package com.server.handsock.services
import com.corundumstudio.socketio.AckRequest
import com.corundumstudio.socketio.SocketIOClient
import com.server.handsock.admin.service.ServerSystemService
import com.server.handsock.clients.service.ClientChannelService
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.props.HandProp
import com.server.handsock.utils.HandUtils
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class AuthService @Autowired constructor(
    private val handProp: HandProp,
    private val tokenService: TokenService,
    private val cacheService: CacheService,
    private val clientService: ClientService,
    private val clientUserService: ClientUserService,
    private val serverSystemService: ServerSystemService,
    private val clientChannelService: ClientChannelService
) {
    fun validClientTokenBySocket(client: SocketIOClient): Boolean {
        try {
            @Suppress("UNCHECKED_CAST")
            val authToken = client.handshakeData.authToken as Map<String, Any>
            val uid = authToken["uid"].toString().toLong()
            return (tokenService.validUserToken(uid, authToken["token"].toString()) && clientUserService.checkUserLogin(uid))
        } catch (e: Exception) {
            return false
        }
    }
    fun validClientTokenByRequest(request: HttpServletRequest): Boolean {
        val token = request.getHeader("token") ?: ""
        val uid = (if (request.getHeader("uid") != null) request.getHeader("uid") else "0").toLong()
        return tokenService.validUserToken(uid, token) && clientUserService.checkUserLogin(uid)
    }
    fun validClientStatusByRequest(request: HttpServletRequest, call: () -> Any): Any {
        return if (validClientTokenByRequest(request)) {
            call()
        } else HandUtils.handleResultByCode(403, null, "非法访问")
    }
    fun validAdminStatusByRequest(request: HttpServletRequest, call: () -> Any): Any {
        val uid = (if (request.getHeader("uid") != null) request.getHeader("uid") else "0").toLong()
        return if (clientUserService.getUserAdminStatusByUid(uid) && validClientTokenByRequest(request)) {
            call()
        } else HandUtils.handleResultByCode(403, null, "非法访问")
    }
    fun validClientStatusBySocket(client: SocketIOClient, call: () -> Any): Any {
        return if (validClientTokenBySocket(client)) {
            call()
        } else HandUtils.handleResultByCode(403, null, "非法访问")
    }
    fun validAdminStatusBySocket(client: SocketIOClient, call: () -> Any): Any {
        return if (clientUserService.queryUserInfo(clientService.getRemoteUID(client)).isAdmin == 1 && validClientTokenBySocket(client)) {
            call()
        } else HandUtils.handleResultByCode(403, null, "非法访问")
    }
    fun validOpenApiRequestLimit(type: String, request: HttpServletRequest, call: () -> Any): Any {
        val address = request.remoteAddr
        return if (tokenService.getOpenApiCache(type, address)) {
            tokenService.setOpenApiCache(type, address)
            val authorization = request.getHeader("Authorization") ?: null
            if (authorization == null || authorization != handProp.openapi) {
                HandUtils.handleResultByCode(403, null, "无权调用此接口")
            } else call()
        } else HandUtils.handleResultByCode(400, null, "请求频繁")
    }
    fun validChatMessageStatusBySocket(client: SocketIOClient, ackRequest: AckRequest, call: () -> Any, data: Map<String?, Any>) {
        if (!validClientTokenBySocket(client)) {
            ackRequest.sendAckData(HandUtils.handleResultByCode(403, null, "登录状态失效"))
            return
        }
        if (!cacheService.validRedisMessageCache(clientService.getRemoteUID(client))) {
            ackRequest.sendAckData(HandUtils.handleResultByCode(402, null, "操作频率过快"))
            return
        }
        if (!clientUserService.getUserInnerStatus(clientService.getRemoteUID(client))) {
            ackRequest.sendAckData(HandUtils.handleResultByCode(402, null, "未查询到用户"))
            return
        }
        if (!clientChannelService.getChanOpenStatus(clientService.getRemoteGID(client))) {
            ackRequest.sendAckData(HandUtils.handleResultByCode(402, null, "该频道未开启"))
            return
        }
        if (serverSystemService.getSystemKeyStatus("taboo") && !clientService.getIsAdmin(client)) {
            ackRequest.sendAckData(HandUtils.handleResultByCode(402, null, "全频禁言开启中"))
            return
        }
        if (clientUserService.getUserTabooStatus(clientService.getRemoteUID(client)) && !clientService.getIsAdmin(client)) {
            ackRequest.sendAckData(HandUtils.handleResultByCode(402, null, "你正在被禁言中"))
            return
        }
        if (clientService.getClientData(data, "content").trim { it <= ' ' }.isEmpty()) {
            ackRequest.sendAckData(HandUtils.handleResultByCode(402, null, "发送内容不能为空"))
            return
        }
        call()
    }
}
package com.server.handsock
import com.corundumstudio.socketio.SocketIOServer
import com.server.handsock.utils.ConsoleUtils
import org.springframework.boot.CommandLineRunner
import org.springframework.stereotype.Component
@Component
class ServerRunner(
    private val socketIOServer: SocketIOServer
) : CommandLineRunner {
    override fun run(vararg args: String) {
        try {
            socketIOServer.start()
            ConsoleUtils.printSuccessLog("Socket.IO server started!")
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.props
import lombok.Getter
import lombok.Setter
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component
@Setter @Getter @Component
@ConfigurationProperties(prefix = "handsock")
open class HandProp {
    var port: Int = 5120
    var host: String? = null
    var origin: String? = null
    var openapi: String? = null
    var pingTimeout: Int = 3000
    var pingInterval: Int = 5000
    var upgradeTimeout: Int = 10000
    var appVersion: String = "2.2.1-B2503221"
}
package com.server.handsock.props
import lombok.Getter
import lombok.Setter
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component
@Setter @Getter @Component
@ConfigurationProperties(prefix = "ai")
open class AiProp {
    var url: String? = null
    var path: String? = null
    var model: String? = null
    var token: String? = null
}
package com.server.handsock
import com.server.handsock.checks.ServerChecker
import com.server.handsock.utils.ConsoleUtils
import org.mybatis.spring.annotation.MapperScan
import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication
import kotlin.system.exitProcess
@SpringBootApplication
@MapperScan("com.server.handsock")
open class HandSock(
    private val serverChecker: ServerChecker
) {
    companion object {
        @JvmStatic
        fun main(args: Array<String>) {
            try {
                System.setProperty("spring.devtools.restart.enabled", "false")
                val context = SpringApplication.run(HandSock::class.java, *args)
                ConsoleUtils.printSuccessLog("Springboot server started!")
                context.getBean(HandSock::class.java).serverChecker.checkMysqlConnection()
                context.getBean(HandSock::class.java).serverChecker.checkRedisConnection()
                context.getBean(HandSock::class.java).serverChecker.checkDatabaseTable()
            } catch (e: Exception) {
                ConsoleUtils.printErrorLog(e)
                exitProcess(0)
            }
        }
    }
}
package com.server.handsock.configs
import com.server.handsock.props.HandProp
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.cors.CorsConfiguration
import org.springframework.web.cors.UrlBasedCorsConfigurationSource
import org.springframework.web.filter.CorsFilter
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer
@Configuration
open class WebCrossConfig @Autowired constructor(private val handProp: HandProp) : WebMvcConfigurer {
    private val corsConfiguration = CorsConfiguration()
    @Bean
    open fun corsFilter(): CorsFilter {
        corsConfiguration.allowCredentials = true
        corsConfiguration.allowedHeaders = listOf("*")
        corsConfiguration.allowedOrigins = listOf(handProp.origin)
        corsConfiguration.allowedMethods = mutableListOf("GET", "POST", "PUT", "DELETE", "OPTIONS")
        val source = UrlBasedCorsConfigurationSource()
        source.registerCorsConfiguration("/**", corsConfiguration)
        return CorsFilter(source)
    }
}
package com.server.handsock.configs
import com.corundumstudio.socketio.SocketIOServer
import com.corundumstudio.socketio.store.RedissonStoreFactory
import com.server.handsock.props.HandProp
import com.server.handsock.sockets.SocketIOListener
import com.server.handsock.sockets.eventer.OnlineEvent
import com.server.handsock.sockets.listener.*
import com.server.handsock.utils.GlobalService
import org.redisson.api.RedissonClient
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Lazy
@Configuration
open class ServiceConfig
@Autowired constructor(
    private val onlineEvent: OnlineEvent,
    private val checkListener: CheckListener,
    private val handProp: HandProp,
    @param:Lazy private val adminListener: AdminListener,
    @param:Lazy private val clientListener: ClientListener,
    @param:Lazy private val searchListener: SearchListener,
    @param:Lazy private val sendingListener: SendingListener,
    @param:Lazy private val userAuthListener: UserAuthListener,
    @param:Lazy private val sysConfigListener: SysConfigListener,
    @param:Lazy private val userUpdateListener: UserUpdateListener,
    @param:Lazy private val userReportListener: UserReportListener
) {
    private val config = com.corundumstudio.socketio.Configuration()
    @Bean
    open fun socketIOServer(redissonClient: RedissonClient?): SocketIOServer {
        config.port = handProp.port
        config.origin = handProp.origin
        config.hostname = handProp.host
        config.pingTimeout = handProp.pingTimeout
        config.pingInterval = handProp.pingInterval
        config.upgradeTimeout = handProp.upgradeTimeout
        config.storeFactory = RedissonStoreFactory(redissonClient)
        val socketIOServer = SocketIOServer(config)
        GlobalService.socketIOServer = socketIOServer
        SocketIOListener(
            onlineEvent = onlineEvent,
            adminListener = adminListener, checkListener = checkListener, clientListener = clientListener,
            searchListener = searchListener, sendingListener = sendingListener, sysConfigListener = sysConfigListener,
            userUpdateListener = userUpdateListener, userReportListener = userReportListener, userAuthListener = userAuthListener
        ).addServerEventListener(socketIOServer)
        return socketIOServer
    }
}
package com.server.handsock.configs
import org.redisson.Redisson
import org.redisson.api.RedissonClient
import org.redisson.config.Config
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
@Configuration
open class RedissonConfig {
    @Value("\${spring.data.redis.url}")
    private val redisUrl: String? = null
    @Bean(destroyMethod = "shutdown")
    open fun redissonClient(): RedissonClient {
        val config = Config()
        config.useSingleServer()
            .setAddress(redisUrl)
            .setConnectionPoolSize(64)
        return Redisson.create(config)
    }
}
package com.server.handsock.configs
import com.fasterxml.jackson.annotation.JsonAutoDetect
import com.fasterxml.jackson.annotation.JsonTypeInfo
import com.fasterxml.jackson.annotation.PropertyAccessor
import com.fasterxml.jackson.databind.ObjectMapper
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.redis.connection.RedisConnectionFactory
import org.springframework.data.redis.core.RedisTemplate
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer
import org.springframework.data.redis.serializer.StringRedisSerializer
@Configuration
open class RedisConfig {
    @Bean
    open fun redisTemplate(redisConnectionFactory: RedisConnectionFactory?): RedisTemplate<String, Any> {
        val template = RedisTemplate<String, Any>()
        template.connectionFactory = redisConnectionFactory
        // 设置键的序列化方式为String
        template.keySerializer = StringRedisSerializer()
        template.hashKeySerializer = StringRedisSerializer()
        // 设置值的序列化方式为JSON
        val jacksonSerializer = Jackson2JsonRedisSerializer(Any::class.java)
        val objectMapper = ObjectMapper()
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY)
        objectMapper.activateDefaultTyping(
            objectMapper.polymorphicTypeValidator,
            ObjectMapper.DefaultTyping.NON_FINAL,
            JsonTypeInfo.As.PROPERTY
        )
        template.valueSerializer = jacksonSerializer
        template.hashValueSerializer = jacksonSerializer
        template.afterPropertiesSet()
        return template
    }
}
package com.server.handsock.clients.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerUserDao
import com.server.handsock.admin.mod.ServerUserModel
import com.server.handsock.admin.service.ServerUserService
import com.server.handsock.clients.dao.ClientUserDao
import com.server.handsock.clients.man.ClientUserManage
import com.server.handsock.clients.mod.ClientUserModel
import com.server.handsock.services.TokenService
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.GlobalService.socketIOServer
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.IDGenerator
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ClientUserService @Autowired constructor(
    private val tokenService: TokenService,
    private val serverUserDao: ServerUserDao,
    private val clientUserDao: ClientUserDao,
    private val serverUserService: ServerUserService,
) {
    fun queryUserInfo(uid: Long): ClientUserModel {
        return clientUserDao.selectById(uid)
    }
    fun queryAllUser(): Map<String, Any> {
        try {
            return HandUtils.handleResultByCode(200, clientUserDao.selectList(null), "获取成功")
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return HandUtils.handleResultByCode(500, null, "服务端异常")
        }
    }
    fun checkUserLogin(uid: Long): Boolean {
        try {
            return clientUserDao.selectOne(QueryWrapper<ClientUserModel>().eq("uid", uid)) != null
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return false
        }
    }
    fun getUserInnerStatus(uid: Long?): Boolean {
        try {
            val selectResult = clientUserDao.selectOne(QueryWrapper<ClientUserModel>().eq("uid", uid))
            return selectResult != null
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return false
        }
    }
    fun getUserTabooStatus(uid: Long?): Boolean {
        try {
            val status = clientUserDao.selectOne(QueryWrapper<ClientUserModel>().eq("uid", uid)).taboo
            return status == "open"
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return false
        }
    }
    val robotInnerStatus: ClientUserModel?
        get() {
            try {
                val selectResult = clientUserDao.selectOne(QueryWrapper<ClientUserModel>().eq("is_robot", 1))
                return selectResult
            } catch (e: Exception) {
                HandUtils.printErrorLog(e)
                return null
            }
        }
    fun getUserInfo(uid: Long?): Map<String, Any> {
        try {
            val selectResult = clientUserDao.selectOne(QueryWrapper<ClientUserModel>().eq("uid", uid))
            return if (selectResult != null) {
                HandUtils.handleResultByCode(200, selectResult, "获取成功")
            } else HandUtils.handleResultByCode(404, null, "用户不存在")
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return HandUtils.handleResultByCode(500, null, "服务端异常")
        }
    }
    fun setUserAiAuthorization(uid: Long?, status: Boolean): Boolean {
        val clientUserModel = ClientUserModel()
        try {
            clientUserModel.uid = uid
            clientUserModel.aiAuth = if (status) 1 else 0
            return clientUserDao.updateById(clientUserModel) > 0
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return false
        }
    }
    fun getUserAdminStatusByUid(uid: Long?): Boolean {
        try {
            val selectResult = clientUserDao.selectOne(QueryWrapper<ClientUserModel>().eq("uid", uid))
            return if (selectResult != null) {
                selectResult.isAdmin == 1
            } else false
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return false
        }
    }
    fun loginUser(username: String, password: String, address: String): Map<String, Any> {
        if (HandUtils.isValidUsername(username) || HandUtils.isValidPassword(password)) return HandUtils.handleResultByCode(400, null, "输入格式不合规")
        try {
            val selectResult = serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("username", username))
            return if (selectResult == null || selectResult.password != HandUtils.encodeStringToMD5(password)) {
                HandUtils.handleResultByCode(409, null, "账号或密码错误")
            } else {
                userLogin(
                    address = address,
                    username = username,
                    selectResult = selectResult
                )
            }
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun loginUserScan(username: String, address: String): Map<String, Any> {
        try {
            val selectResult = serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("username", username))
            return if (selectResult == null) {
                HandUtils.handleResultByCode(409, null, "未查询到用户")
            } else {
                userLogin(
                    address = address,
                    username = username,
                    selectResult = selectResult
                )
            }
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun registerUser(username: String, password: String, address: String?): Map<String, Any> {
        if (HandUtils.isValidUsername(username) || HandUtils.isValidPassword(password)) return HandUtils.handleResultByCode(400, null, "输入格式不合规")
        if (serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("username", username)) != null) {
            return HandUtils.handleResultByCode(409, null, "用户名已存在")
        } else {
            try {
                val uid = generateUniqueUid()
                val serverUserModel = ServerUserModel()
                val result = ClientUserManage().registerUser(serverUserModel, uid, username, HandUtils.encodeStringToMD5(password), address)
                val userinfo = result["userinfo"] as Map<*, *>?
                result["token"] =
                    tokenService.generateUserToken(userinfo!!["uid"].toString().toLong(), username, address!!)
                val token = result["token"]
                if (serverUserDao.insert(serverUserModel) > 0) {
                    ConsoleUtils.printInfoLog("User Register $address $uid $token")
                    HandUtils.sendGlobalMessage(socketIOServer!!, "[RE:USER:ALL]", null)
                    return HandUtils.handleResultByCode(200, result, "注册成功")
                } else return HandUtils.handleResultByCode(407, null, "注册失败")
            } catch (e: Exception) {
                return HandUtils.printErrorLog(e)
            }
        }
    }
    fun editForNick(uid: Long, nick: String): Map<String, Any> {
        if (nick.length > 10 || nick.length < 2) return HandUtils.handleResultByCode(400, null, "昵称长度不合规")
        try {
            val serverUserModel = ServerUserModel()
            val result = ClientUserManage().updateNick(serverUserModel, uid, nick)
            if (serverUserDao.updateById(serverUserModel) > 0) {
                HandUtils.sendGlobalMessage(
                    event = "[RE:USER:NICK]",
                    server = socketIOServer!!,
                    content = HandUtils.handleResultByCode(200, result, "修改昵称成功")
                )
                return HandUtils.handleResultByCode(200, result, "修改昵称成功")
            } else return HandUtils.handleResultByCode(400, result, "修改昵称失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun editForAvatar(uid: Long, path: String?): Map<String, Any> {
        try {
            val serverUserModel = ServerUserModel()
            val result = ClientUserManage().updateAvatar(serverUserModel, uid, path)
            if (serverUserDao.updateById(serverUserModel) > 0) {
                HandUtils.sendGlobalMessage(
                    event = "[RE:USER:AVATAR]",
                    server = socketIOServer!!,
                    content = HandUtils.handleResultByCode(200, result, "修改头像成功")
                )
                return HandUtils.handleResultByCode(200, result, "修改头像成功")
            } else return HandUtils.handleResultByCode(400, result, "修改头像失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun editForUserName(uid: Long, username: String): Map<String, Any> {
        if (HandUtils.isValidUsername(username)) return HandUtils.handleResultByCode(400, null, "账号格式不合规")
        try {
            val serverUserModel = ServerUserModel()
            val result = ClientUserManage().updateUserName(serverUserModel, uid, username)
            if (serverUserDao.updateById(serverUserModel) > 0) {
                HandUtils.sendGlobalMessage(
                    event = "[RE:USER:USERNAME]",
                    server = socketIOServer!!,
                    content = HandUtils.handleResultByCode(200, result, "修改用户名成功")
                )
                return HandUtils.handleResultByCode(200, result, "修改账号成功")
            } else return HandUtils.handleResultByCode(400, result, "修改账号失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun editForPassword(uid: Long, password: String): Map<String, Any> {
        if (HandUtils.isValidPassword(password)) return HandUtils.handleResultByCode(400, null, "密码格式不合规")
        try {
            val serverUserModel = ServerUserModel()
            ClientUserManage().updatePassword(serverUserModel, uid, HandUtils.encodeStringToMD5(password))
            return if (serverUserDao.updateById(serverUserModel) > 0) {
                HandUtils.handleResultByCode(200, null, "修改密码成功")
            } else HandUtils.handleResultByCode(400, null, "修改密码失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun getUserQrcodeScanStatus(qid: String, address: String): Map<String, Any> {
        try {
            val status = tokenService.getScanStatus(qid)
                ?: return HandUtils.handleResultByCode(401, null, "二维码已过期")
            return when(status) {
                "0" -> HandUtils.handleResultByCode(400, null, "等待扫码中")
                "1" -> {
                    val targetUser = tokenService.getScanTargetUser(qid)
                        ?: return HandUtils.handleResultByCode(500, null, "服务器异常")
                    val user = serverUserService.getUserInfo(targetUser.toLong())
                    tokenService.removeScanStatus(qid)
                    loginUserScan(
                        address = address,
                        username = user.username,
                    )
                }
                else -> HandUtils.handleResultByCode(500, null, "服务器异常")
            }
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    private fun generateUniqueUid(): Long {
        var uid: Long
        do {
            uid = IDGenerator.generateRandomId(8)
        } while (serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("uid", uid)) != null)
        return uid
    }
    private fun userLogin(selectResult: ServerUserModel, username: String, address: String): Map<String, Any> {
        val uid = selectResult.uid
        val token = tokenService.generateUserToken(selectResult.uid, username, address)
        ConsoleUtils.printInfoLog("User Login $address $uid $token")
        return HandUtils.handleResultByCode(200, java.util.Map.of("token", token, "userinfo", clientUserDao.selectOne(QueryWrapper<ClientUserModel>().eq("username", username))), "登录成功")
    }
}
package com.server.handsock.clients.service
import com.server.handsock.clients.dao.ClientReportDao
import com.server.handsock.clients.man.ClientReportManage
import com.server.handsock.clients.mod.ClientReportModel
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.IDGenerator
import lombok.Getter
import lombok.Setter
import org.springframework.stereotype.Service
@Service @Setter @Getter
class ClientReportService(private val clientReportDao: ClientReportDao) {
    fun addReport(sid: String?, reporterId: Long, reportedId: Long, reason: String?): Map<String, Any> {
        try {
            if (reporterId == reportedId) {
                return HandUtils.handleResultByCode(400, null, "不能举报自己")
            } else {
                val clientReportModel = ClientReportModel()
                ClientReportManage(HandUtils, IDGenerator).insertRepo(clientReportModel, sid, reporterId, reportedId, reason)
                return if (clientReportDao.insert(clientReportModel) > 0) {
                    HandUtils.handleResultByCode(200, null, "举报成功")
                } else HandUtils.handleResultByCode(400, null, "举报失败")
            }
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.clients.service
import com.server.handsock.clients.dao.ClientNoticeDao
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ClientNoticeService @Autowired constructor(private val clientNoticeDao: ClientNoticeDao) {
    fun searchAllNotice(): Map<String, Any> {
        try {
            val noticeList = clientNoticeDao.selectList(null)
            noticeList.reverse()
            return HandUtils.handleResultByCode(200, noticeList, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.clients.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.clients.dao.ClientChatDao
import com.server.handsock.clients.man.ClientChatManage
import com.server.handsock.clients.mod.ClientChatModel
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.IDGenerator
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ClientChatService @Autowired constructor(private val clientChatDao: ClientChatDao) {
    fun insertChatMessage(type: String, uid: Long, gid: Long, address: String, content: String): Map<String, Any> {
        try {
            if (content.length > 200) return HandUtils.handleResultByCode(400, null, "消息过长")
            val clientChatModel = ClientChatModel()
            val result = ClientChatManage(HandUtils, ConsoleUtils, IDGenerator).insertChatMessage(clientChatModel, type, uid, gid, address, content)
            return if (clientChatDao.insert(clientChatModel) > 0) {
                HandUtils.handleResultByCode(200, result, "发送成功")
            } else HandUtils.handleResultByCode(400, null, "发送失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun searchAllChatHistory(gid: Long?): Map<String, Any> {
        try {
            val wrapper = QueryWrapper<ClientChatModel>()
            wrapper.orderByAsc("time")
            return HandUtils.handleResultByCode(200, clientChatDao.selectList(wrapper.eq("gid", gid)), "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.clients.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.clients.dao.ClientChannelDao
import com.server.handsock.clients.mod.ClientChannelModel
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ClientChannelService @Autowired constructor(private val clientChannelDao: ClientChannelDao) {
    fun searchAllGroup(): Map<String, Any> {
        try {
            val clientChannelModelList = clientChannelDao.selectList(QueryWrapper<ClientChannelModel>().eq("active", 1))
            val history: MutableList<Map<String, Any>> = ArrayList()
            for (clientChannelModel in clientChannelModelList) {
                history.add(object : HashMap<String, Any>() {
                    init {
                        clientChannelModel.gid?.let { put("gid", it) }
                    }
                })
            }
            val result = HandUtils.handleResultByCode(200, clientChannelModelList, "获取成功").apply {
                "latest" to history
            }
            return result
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun searchGroupByGid(gid: Long): Map<String, Any> {
        try {
            val groupSelect = if (gid == 0L) {
                clientChannelDao.selectOne(QueryWrapper<ClientChannelModel>().eq("home", 1))
            } else clientChannelDao.selectOne(QueryWrapper<ClientChannelModel>().eq("gid", gid))
            return if (groupSelect == null) {
                HandUtils.handleResultByCode(404, null, "未找到频道")
            } else HandUtils.handleResultByCode(200, groupSelect, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun getChanOpenStatus(gid: Long?): Boolean {
        try {
            val status = clientChannelDao.selectOne(QueryWrapper<ClientChannelModel>().eq("gid", gid)).open
            return status == 1
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return false
        }
    }
}
package com.server.handsock.clients.service
import com.server.handsock.clients.dao.ClientBannerDao
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ClientBannerService @Autowired constructor(private val clientBannerDao: ClientBannerDao) {
    fun searchAllBanner(): Map<String, Any> {
        try {
            val bannerList = clientBannerDao.selectList(null)
            return HandUtils.handleResultByCode(200, bannerList, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.clients.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_user")
public class ClientUserModel {
    @TableId
    public Long uid;
    public String nick;
    public int isAdmin;
    public int isRobot;
    public String taboo;
    public String email;
    public String avatar;
    public Integer aiAuth;
    public String regTime;
    public String username;
}
package com.server.handsock.clients.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_report")
public class ClientReportModel {
    @TableId
    public String rid;
    public String sid;
    public String time;
    public String reason;
    public Long reporterId;
    public Long reportedId;
}
package com.server.handsock.clients.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_notice")
public class ClientNoticeModel {
    @TableId
    private Integer nid;
    private String time;
    private String title;
    private String content;
}
package com.server.handsock.clients.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_message")
public class ClientChatModel {
    public Long uid;
    public Long gid;
    @TableId
    public String sid;
    public int deleted;
    public String type;
    public String time;
    public String address;
    public String content;
}
package com.server.handsock.clients.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_channel")
public class ClientChannelModel {
    @TableId
    public Long gid;
    public String name;
    public Integer open;
    public Integer home;
    public String notice;
    public String avatar;
    public Integer active;
    public Integer aiRole;
}
package com.server.handsock.clients.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_banner")
public class ClientBannerModel {
    @TableId
    private Integer bid;
    private String name;
    private String href;
    private String image;
}
package com.server.handsock.clients.man;
import com.server.handsock.admin.mod.ServerUserModel;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
public class ClientUserManage {
    public Map<String, Object> updateNick(ServerUserModel server_userModel, long uid, String nick) {
        server_userModel.setUid(uid);
        server_userModel.setNick(nick);
        return new HashMap<>() {{
            put("uid", server_userModel.getUid());
            put("nick", server_userModel.getNick());
        }};
    }
    public Map<String, Object> updateAvatar(ServerUserModel server_userModel, long uid, String path) {
        server_userModel.setUid(uid);
        server_userModel.setAvatar(path);
        return new HashMap<>() {{
            put("uid", server_userModel.getUid());
            put("avatar", server_userModel.getAvatar());
        }};
    }
    public Map<String, Object> updateUserName(ServerUserModel server_userModel, long uid, String username) {
        server_userModel.setUid(uid);
        server_userModel.setUsername(username);
        return new HashMap<>() {{
            put("uid", server_userModel.getUid());
            put("username", server_userModel.getUsername());
        }};
    }
    public void updatePassword(ServerUserModel server_userModel, long uid, String password) {
        server_userModel.setUid(uid);
        server_userModel.setPassword(password);
    }
    public Map<String, Object> registerUser(ServerUserModel server_userModel, long uid, String username, String password, String address) {
        server_userModel.setUid(uid);
        server_userModel.setNick("热心网友");
        server_userModel.setAvatar("0/default/" + new Random().nextInt(7) + ".png");
        server_userModel.setUsername(username);
        server_userModel.setPassword(password);
        return new HashMap<>() {{
            put("userinfo", new HashMap<>() {{
                put("uid", uid);
                put("isAdmin", 0);
                put("isRobot", 0);
                put("nick", server_userModel.getNick());
                put("avatar", server_userModel.getAvatar());
                put("username", server_userModel.getUsername());
            }});
        }};
    }
}
package com.server.handsock.clients.man;
import com.server.handsock.clients.mod.ClientReportModel;
import com.server.handsock.utils.HandUtils;
import com.server.handsock.utils.IDGenerator;
public class ClientReportManage {
    private final HandUtils handUtils;
    private final IDGenerator idGenerator;
    public ClientReportManage(HandUtils handUtils, IDGenerator idGenerator) {
        this.handUtils = handUtils;
        this.idGenerator = idGenerator;
    }
    public void insertRepo(ClientReportModel clientReportModel, String sid, Long reporter_id, Long reported_id, String reason) {
        clientReportModel.setSid(sid);
        clientReportModel.setReason(reason);
        clientReportModel.setTime(handUtils.formatTimeForString("yyyy-MM-dd HH:mm:ss"));
        clientReportModel.setReporterId(reporter_id);
        clientReportModel.setReportedId(reported_id);
        clientReportModel.setRid(idGenerator.generateRandomReportedId(sid, reporter_id, reported_id));
    }
}
package com.server.handsock.clients.man;
import com.server.handsock.clients.mod.ClientChatModel;
import com.server.handsock.utils.ConsoleUtils;
import com.server.handsock.utils.HandUtils;
import com.server.handsock.utils.IDGenerator;
import java.util.HashMap;
import java.util.Map;
public class ClientChatManage {
    private final HandUtils handUtils;
    private final IDGenerator idGenerator;
    private final ConsoleUtils consoleUtils;
    public ClientChatManage(HandUtils handUtils, ConsoleUtils consoleUtils, IDGenerator idGenerator) {
        this.handUtils = handUtils;
        this.idGenerator = idGenerator;
        this.consoleUtils = consoleUtils;
    }
    public Map<String, Object> insertChatMessage(ClientChatModel clientChatModel, String type, long uid, long gid, String address, String content) {
        clientChatModel.setUid(uid);
        clientChatModel.setGid(gid);
        clientChatModel.setType(type);
        clientChatModel.setDeleted(0);
        clientChatModel.setAddress(address);
        clientChatModel.setTime(handUtils.formatTimeForString("yyyy-MM-dd HH:mm:ss"));
        clientChatModel.setContent(content);
        clientChatModel.setSid(idGenerator.generateRandomMessageId(uid, gid, address));
        consoleUtils.printInfoLog("User Message " + clientChatModel.getAddress() + " " + clientChatModel.getUid() + " " + clientChatModel.getGid() + " " + clientChatModel.getSid());
        return new HashMap<>() {{
            put("sid", clientChatModel.getSid());
            put("uid", clientChatModel.getUid());
            put("gid", clientChatModel.getGid());
            put("type", clientChatModel.getType());
            put("time", clientChatModel.getTime());
            put("deleted", clientChatModel.getDeleted());
            put("content", clientChatModel.getContent());
        }};
    }
}
package com.server.handsock.clients.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.clients.mod.ClientUserModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ClientUserDao extends BaseMapper<ClientUserModel> {
}
package com.server.handsock.clients.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.clients.mod.ClientReportModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ClientReportDao extends BaseMapper<ClientReportModel> {
}
package com.server.handsock.clients.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.clients.mod.ClientNoticeModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ClientNoticeDao extends BaseMapper<ClientNoticeModel> {}
package com.server.handsock.clients.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.clients.mod.ClientChatModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ClientChatDao extends BaseMapper<ClientChatModel> {
}
package com.server.handsock.clients.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.clients.mod.ClientChannelModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ClientChannelDao extends BaseMapper<ClientChannelModel> {
}
package com.server.handsock.clients.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.clients.mod.ClientBannerModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ClientBannerDao extends BaseMapper<ClientBannerModel> {}
package com.server.handsock.clients.controller
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.AuthService
import com.server.handsock.services.TokenService
import com.server.handsock.utils.HandUtils
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.*
@RestController
@RequestMapping("/user")
class ClientUserController @Autowired constructor(
    private val authService: AuthService,
    private val tokenService: TokenService,
    private val clientUserService: ClientUserService
) {
    @PostMapping("/login")
    fun userLogin(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Map<String, Any> {
        try {
            val username = data["username"]?.toString()
            val password = data["password"]?.toString()
            val androidId = request.getHeader("androidId")
            return if (username == null || password == null || androidId == null) {
                HandUtils.handleResultByCode(403, null, "参数错误")
            } else clientUserService.loginUser(username, password, androidId)
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    @PostMapping("/register")
    fun userRegister(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Map<String, Any> {
        try {
            val username = data["username"]?.toString()
            val password = data["password"]?.toString()
            val androidId = request.getHeader("androidId")
            return if (username == null || password == null || androidId == null) {
                HandUtils.handleResultByCode(403, null, "参数错误")
            } else clientUserService.registerUser(username, password, androidId)
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    @GetMapping("/info")
    fun getUserInfo(request: HttpServletRequest, @RequestParam("uid") uid: Long?): Any {
        return authService.validClientStatusByRequest(request) {
            clientUserService.getUserInfo(uid)
        }
    }
    @PostMapping("/edit/avatar")
    fun editAvatar(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            val path = data["path"].toString()
            val uid = data["uid"].toString().toLong()
            clientUserService.editForAvatar(uid, path)
        }
    }
    @PostMapping("/edit/nick")
    fun editNick(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            val uid = data["uid"].toString().toLong()
            val nick = data["nick"].toString()
            clientUserService.editForNick(uid, nick)
        }
    }
    @PostMapping("/edit/username")
    fun editUserName(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            val uid = data["uid"].toString().toLong()
            val username = data["username"].toString()
            clientUserService.editForUserName(uid, username)
        }
    }
    @PostMapping("/edit/password")
    fun editPassword(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            val uid = data["uid"].toString().toLong()
            val password = data["password"].toString()
            clientUserService.editForPassword(uid, password)
        }
    }
    @PostMapping("/scan/login")
    fun userScanLogin(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            try {
                val uid = data["uid"].toString()
                val qid = data["qid"].toString()
                val status = data["status"].toString().toInt()
                when(status) {
                    0 -> {
                        tokenService.removeScanStatus(qid)
                        HandUtils.handleResultByCode(200, null, "已取消登录")
                    }
                    1 -> {
                        tokenService.setScanStatus(qid, 1)
                        tokenService.setScanTargetUser(
                            qid = qid,
                            uid = uid
                        )
                        HandUtils.handleResultByCode(200, null, "登录成功")
                    }
                    else -> HandUtils.handleResultByCode(400, null, "未知参数")
                }
            } catch (e: Exception) {
                HandUtils.printErrorLog(e)
            }
        }
    }
    @PostMapping("/scan/status")
    fun getQrcodeScanStatus(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            try {
                val qid = data["qid"].toString()
                val androidId = "Android Check"
                clientUserService.getUserQrcodeScanStatus(
                    qid = qid,
                    address = androidId
                )
            } catch (e: Exception) {
                HandUtils.printErrorLog(e)
            }
        }
    }
}
package com.server.handsock.clients.controller
import com.server.handsock.admin.service.ServerSystemService
import com.server.handsock.services.AuthService
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
@RestController
@RequestMapping("/android/system")
class AndroidController @Autowired constructor(
    private val authService: AuthService,
    private val serverSystemService: ServerSystemService
) {
    @PostMapping("/update")
    fun checkAppUpdate(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            val version = data["version"].toString()
            serverSystemService.checkAppUpdate(version)
        }
    }
}
package com.server.handsock.clients.controller
import com.server.handsock.clients.service.ClientNoticeService
import com.server.handsock.services.AuthService
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
@RestController
@RequestMapping("/android/notice")
class ClientNoticeController @Autowired constructor(
    private val authService: AuthService,
    private val clientNoticeService: ClientNoticeService
) {
    @GetMapping("/search/all")
    fun searchAllNotice(request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            clientNoticeService.searchAllNotice()
        }
    }
}
package com.server.handsock.clients.controller
import com.server.handsock.clients.service.ClientChannelService
import com.server.handsock.services.AuthService
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.*
@RestController
@RequestMapping("/android/channel")
class ClientChannelController @Autowired constructor(
    private val authService: AuthService,
    private val clientChannelService: ClientChannelService
) {
    @GetMapping("/search/all")
    fun searchAllGroup(request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            clientChannelService.searchAllGroup()
        }
    }
    @PostMapping("/search/gid")
    fun searchGroupByGid(request: HttpServletRequest, @RequestBody data: Map<String?, Any>): Any {
        return authService.validClientStatusByRequest(request) {
            clientChannelService.searchGroupByGid(data["gid"].toString().toLong())
        }
    }
}
package com.server.handsock.clients.controller
import com.server.handsock.clients.service.ClientBannerService
import com.server.handsock.services.AuthService
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
@RestController
@RequestMapping("/android/banner")
class ClientBannerController @Autowired constructor(
    private val authService: AuthService,
    private val clientBannerService: ClientBannerService
) {
    @GetMapping("/search/all")
    fun searchAllBanner(request: HttpServletRequest): Any {
        return authService.validClientStatusByRequest(request) {
            clientBannerService.searchAllBanner()
        }
    }
}
package com.server.handsock.checks
import com.server.handsock.utils.ConsoleUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Value
import org.springframework.data.redis.connection.RedisConnection
import org.springframework.data.redis.core.StringRedisTemplate
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.stereotype.Component
import kotlin.system.exitProcess
@Component
class ServerChecker @Autowired constructor(
    private val jdbcTemplate: JdbcTemplate,
    private val redisTemplate: StringRedisTemplate
) {
    private val mysqlChecker = MysqlChecker()
    @Value("\${spring.datasource.url}")
    private val databaseUrl: String? = null
    @Value("\${spring.datasource.username}")
    private val databaseUsername: String? = null
    @Value("\${spring.datasource.password}")
    private val databasePassword: String? = null
    @Value("\${spring.datasource.driver-class-name}")
    private val databaseDriver: String? = null
    fun checkMysqlConnection() {
        try {
            val result = jdbcTemplate.queryForList("SELECT 1")
            if (result.isNotEmpty()) {
                ConsoleUtils.printSuccessLog("Mysql server connect success!")
            } else shutdown(Throwable("Redis server connect failed!"))
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
            shutdown(Throwable("Redis server connect failed!"))
        }
    }
    fun checkRedisConnection() {
        try {
            val pingResult = redisTemplate.execute { obj: RedisConnection -> obj.ping() }
            if ("PONG".equals(pingResult, ignoreCase = true)) {
                ConsoleUtils.printSuccessLog("Redis server connect success!")
            } else shutdown(Throwable("\"Mysql server connect failed!"))
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
            shutdown(Throwable("Redis server connect failed!"))
        }
    }
    fun checkDatabaseTable() {
        try {
            mysqlChecker.checkTable(databaseDriver, databaseUrl, databaseUsername, databasePassword)
            ConsoleUtils.printSuccessLog("Database table check success!")
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
            shutdown(Throwable("Database table checked failed!"))
        }
    }
    companion object {
        private fun shutdown(content: Throwable) {
            ConsoleUtils.printErrorLog(content)
            exitProcess(0)
        }
    }
}
package com.server.handsock.checks;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.SQLException;
public class MysqlChecker {
    private final String USER_TABLE_NAME = "handsock_user";
    private final String BANNER_TABLE_NAME = "handsock_banner";
    private final String NOTICE_TABLE_NAME = "handsock_notice";
    private final String REPORT_TABLE_NAME = "handsock_report";
    private final String SYSTEM_TABLE_NAME = "handsock_system";
    private final String UPLOAD_TABLE_NAME = "handsock_upload";
    private final String MESSAGE_TABLE_NAME = "handsock_message";
    private final String CHANNEL_TABLE_NAME = "handsock_channel";
    private final String CREATE_USER_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `uid` bigint(20) NOT NULL,
                    `nick` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '热心网友',
                    `taboo` varchar(5) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'close',
                    `email` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
                    `avatar` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT 'https://dn-qiniu-avatar.qbox.me/avatar/',
                    `ai_auth` int(1) NOT NULL DEFAULT '0',
                    `reg_time` datetime DEFAULT CURRENT_TIMESTAMP,
                    `is_robot` int(1) NOT NULL DEFAULT '0',
                    `is_admin` int(1) NOT NULL DEFAULT '0',
                    `username` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
                    `password` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,
                    PRIMARY KEY (uid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(USER_TABLE_NAME);
    private final String CREATE_SYSTEM_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `yid` bigint(5) NOT NULL,
                    `time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    `name` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
                    `value` text COLLATE utf8mb4_unicode_ci,
                    PRIMARY KEY (yid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(SYSTEM_TABLE_NAME);
    private final String CREATE_UPLOAD_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `fid` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `uid` bigint(20) NOT NULL,
                    `size` bigint(20) NOT NULL,
                    `time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    `name` text COLLATE utf8mb4_unicode_ci NOT NULL,
                    `path` text COLLATE utf8mb4_unicode_ci NOT NULL,
                    `type` varchar(10) COLLATE utf8mb4_unicode_ci NOT NULL,
                    PRIMARY KEY (fid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(UPLOAD_TABLE_NAME);
    private final String CREATE_REPORT_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `rid` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `sid` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    `reason` text COLLATE utf8mb4_unicode_ci NOT NULL,
                    `deleted` int(1) DEFAULT '0',
                    `reporter_id` bigint(20) NOT NULL,
                    `reported_id` bigint(20) NOT NULL,
                    PRIMARY KEY (rid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(REPORT_TABLE_NAME);
    private final String CREATE_MESSAGE_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `sid` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `uid` bigint(20) NOT NULL,
                    `gid` bigint(20) NOT NULL,
                    `type` varchar(10) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    `address` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
                    `content` text COLLATE utf8mb4_unicode_ci NOT NULL,
                    `deleted` int(1) DEFAULT '0',
                    PRIMARY KEY (sid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(MESSAGE_TABLE_NAME);
    private final String CREATE_CHANNEL_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `gid` bigint(20) NOT NULL,
                    `name` varchar(10) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `open` int(1) NOT NULL DEFAULT '1',
                    `home` int(1) NOT NULL DEFAULT '0',
                    `active` int(1) NOT NULL DEFAULT '0',
                    `avatar` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
                    `notice` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '当前频道暂无公告',
                    `ai_role` int(1) NOT NULL DEFAULT '0',
                    PRIMARY KEY (gid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(CHANNEL_TABLE_NAME);
    private final String CREATE_BANNER_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `bid` int(11) NOT NULL AUTO_INCREMENT,
                    `name` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `href` text CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
                    `image` text CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
                    PRIMARY KEY (bid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(BANNER_TABLE_NAME);
    private final String CREATE_NOTICE_TABLE_SQL = """
                CREATE TABLE IF NOT EXISTS %s (
                    `nid` int(11) NOT NULL AUTO_INCREMENT,
                    `time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    `title` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
                    `content` text CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
                    PRIMARY KEY (nid)
                ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
            """.formatted(NOTICE_TABLE_NAME);
    private final String INSERT_USER_SQL = """
                INSERT INTO %s (`uid`, `nick`, `taboo`, `email`, `avatar`, `ai_auth`, `reg_time`, `is_robot`, `is_admin`, `username`, `password`) VALUES
                    (2400442120, 'AdminUser', 'close', NULL, '0/default/0.png', 1, CURRENT_TIMESTAMP, 0, 1, 'handsock', 'd0775d11a4c67b9e8df44c336fac3371'),
                    (2400408600, 'RobotUser', 'close', NULL, '0/default/1.png', 0, CURRENT_TIMESTAMP, 1, 0, 'robot123', 'c51ce410c124a10e0db5e4b97fc2af39');
            """.formatted(USER_TABLE_NAME);
    private final String INSERT_SYSTEM_SQL = """
                INSERT INTO %s (`yid`, `name`, `value`) VALUES
                    (1, 'taboo', 'close'),
                    (2, 'upload', 'open'),
                    (3, 'register', 'open'),
                    (4, 'playlist', '2520739691'),
                    (5, 'version', '2.1.2'),
                    (6, 'download', 'http://lc-6piuorK4.cn-n1.lcfile.com/lPKEysQMNIkkHcSSgl7mHrHq7HuDBrPE/app-release.apk');
            """.formatted(SYSTEM_TABLE_NAME);
    private final String INSERT_CHANNEL_SQL = """
                INSERT INTO %s (`gid`, `name`, `open`, `home`, `active`, `avatar`, `ai_role`) VALUES
                    (0, '猪的神奇聊天室', 1, 1, 1, '/image/avatar.jpeg', 0),
                    (1, '猪的测试聊天室', 1, 0, 1, '/image/avatar.jpeg', 0),
                    (2, '人工智能聊天室', 1, 0, 1, '/image/chatgpt.png', 1),
                    (3, '项目进展阅览室', 1, 0, 1, '/image/handsock.png', 0);
            """.formatted(CHANNEL_TABLE_NAME);
    private final String INSERT_BANNER_SQL = """
                INSERT INTO %s (`bid`, `name`, `href`, `image`) VALUES
                    (1, 'APP正式上线啦', 'https://doc.handsock.xiaokolomi.cn/depoly/android.html', 'https://mmbiz.qpic.cn/sz_mmbiz_png/67YpKzccxKeXCwkeSl8nRuLxKgiazZpB5Ll4M1eH41xuqfXPkJ4LUAmU3ExWxOJJpoiaFSW51LYN2TD25VVncw4Q/640?wx_fmt=png&amp;from=appmsg'),
                    (2, '加入我们的群聊', 'https://qm.qq.com/q/AKdIXRHMBM', 'https://mmbiz.qpic.cn/sz_mmbiz_png/67YpKzccxKeXCwkeSl8nRuLxKgiazZpB5fUSmEWYhBoLYAKMibHNuZgiaJ38aNAAAdd7MsNe9nk6eFRpB3erDSG1g/640?wx_fmt=png&amp;from=appmsg'),
                    (3, '聊天类软件定制', 'hhttps://doc.handsock.xiaokolomi.cn/depoly/android.html', 'https://mmbiz.qpic.cn/sz_mmbiz_png/67YpKzccxKeXCwkeSl8nRuLxKgiazZpB5EfMor7ibBvicEyhALLNv2b6XIbbT0BBRzamcd62dM9pB8p0u4KhWeTibA/640?wx_fmt=png&amp;from=appmsg'),
                    (4, '广告位限时招租', 'https://doc.handsock.xiaokolomi.cn/depoly/ad-leasing.html', 'https://mmbiz.qpic.cn/sz_mmbiz_png/67YpKzccxKeXCwkeSl8nRuLxKgiazZpB5thy1VFlvqxoLxeBKOoqyYdLzngibwEib0KvgnzsBgwGmcZXLibI6gRLkw/640?wx_fmt=png&amp;from=appmsg');
            """.formatted(BANNER_TABLE_NAME);
    public void checkTable(String databaseDriver, String databaseUrl, String databaseUsername, String databasePassword) throws ClassNotFoundException, SQLException {
        Class.forName(databaseDriver);
        Connection connection = DriverManager.getConnection(databaseUrl, databaseUsername, databasePassword);
        DatabaseMetaData dbMetaData = connection.getMetaData();
        if (!dbMetaData.getTables(null, null, USER_TABLE_NAME, null).next()) createUserTable(connection);
        if (!dbMetaData.getTables(null, null, BANNER_TABLE_NAME, null).next()) createBannerTable(connection);
        if (!dbMetaData.getTables(null, null, NOTICE_TABLE_NAME, null).next()) createNoticeTable(connection);
        if (!dbMetaData.getTables(null, null, SYSTEM_TABLE_NAME, null).next()) createSystemTable(connection);
        if (!dbMetaData.getTables(null, null, UPLOAD_TABLE_NAME, null).next()) createUploadTable(connection);
        if (!dbMetaData.getTables(null, null, REPORT_TABLE_NAME, null).next()) createReportTable(connection);
        if (!dbMetaData.getTables(null, null, MESSAGE_TABLE_NAME, null).next()) createMessageTable(connection);
        if (!dbMetaData.getTables(null, null, CHANNEL_TABLE_NAME, null).next()) createChannelTable(connection);
    }
    public void createUserTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_USER_TABLE_SQL);
        connection.createStatement().execute(INSERT_USER_SQL);
    }
    public void createBannerTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_BANNER_TABLE_SQL);
        connection.createStatement().execute(INSERT_BANNER_SQL);
    }
    public void createNoticeTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_NOTICE_TABLE_SQL);
    }
    public void createSystemTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_SYSTEM_TABLE_SQL);
        connection.createStatement().execute(INSERT_SYSTEM_SQL);
    }
    public void createUploadTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_UPLOAD_TABLE_SQL);
    }
    public void createReportTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_REPORT_TABLE_SQL);
    }
    public void createMessageTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_MESSAGE_TABLE_SQL);
    }
    public void createChannelTable(Connection connection) throws SQLException {
        connection.createStatement().execute(CREATE_CHANNEL_TABLE_SQL);
        connection.createStatement().execute(INSERT_CHANNEL_SQL);
    }
}
package com.server.handsock.api.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerUserDao
import com.server.handsock.admin.mod.ServerUserModel
import com.server.handsock.admin.service.ServerSystemService
import com.server.handsock.api.dao.UploadDao
import com.server.handsock.api.man.UploadManage
import com.server.handsock.api.mod.UploadModel
import com.server.handsock.clients.dao.ClientChannelDao
import com.server.handsock.clients.mod.ClientChannelModel
import com.server.handsock.clients.service.ClientChannelService
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.CacheService
import com.server.handsock.services.TokenService
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.IDGenerator
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpHeaders
import org.springframework.stereotype.Service
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.multipart.MultipartFile
import java.io.IOException
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.*
@Service
class UploadService @Autowired constructor(
    private val uploadDao: UploadDao,
    private val tokenService: TokenService,
    private val cacheService: CacheService,
    private val serverUserDao: ServerUserDao,
    private val clientChannelDao: ClientChannelDao,
    private val clientUserService: ClientUserService,
    private val serverSystemService: ServerSystemService,
    private val clientChannelService: ClientChannelService
) {
    /**
     * Handles file upload from client.
     *
     * @param headers HTTP headers containing user and group information.
     * @param file    the file to be uploaded.
     * @return a map containing the result of the upload operation.
     */
    @Throws(IOException::class)
    fun clientUploadFile(headers: HttpHeaders, @RequestParam("file") file: MultipartFile, type: String): Map<String, Any> {
        val uidHeader = headers["uid"]
        val gidHeader = headers["gid"]
        val tokenHeader = headers["token"]
        val fileWith = type == "files" || type == "images"
        if (!isValidRequest(
            uidHeader = uidHeader,
            gidHeader = gidHeader,
            tokenHeader = tokenHeader
        )) return HandUtils.handleResultByCode(400, null, "禁止访问")
        if (!cacheService.validRedisUploadCache(gidHeader!![0].toLong())) {
            return HandUtils.handleResultByCode(402, null, "操作频率过快")
        } else cacheService.writeRedisUploadCache(gidHeader[0].toLong())
        if (fileWith && !clientChannelService.getChanOpenStatus(gidHeader[0].toLong())) {
            return HandUtils.handleResultByCode(402, null, "该频道未开启")
        }
        if (fileWith && serverSystemService.getSystemKeyStatus("taboo") && !clientUserService.getUserAdminStatusByUid(uidHeader!![0].toLong())) {
            return HandUtils.handleResultByCode(402, null, "全频禁言开启中")
        }
        if (!serverSystemService.getSystemKeyStatus("upload") && !clientUserService.getUserAdminStatusByUid(uidHeader!![0].toLong())) {
            return HandUtils.handleResultByCode(402, null, "上传权限未开放")
        }
        if (fileWith && clientUserService.getUserTabooStatus(uidHeader!![0].toLong()) && !clientUserService.getUserAdminStatusByUid(uidHeader[0].toLong())) {
            return HandUtils.handleResultByCode(402, null, "你正在被禁言中")
        }
        val time = HandUtils.encodeStringToMD5(HandUtils.formatTimeForString("yyyy-MM-dd-HH-mm-ss"))
        val uploadDir = createUploadDirectory(
            type = type,
            time = time,
            uid = uidHeader!![0]
        )
        try {
            val uploadModel = UploadModel()
            val uid = uidHeader[0].toLong()
            val fileName = file.originalFilename
            val filePath = "$uid/$time/$fileName"
            Files.write(uploadDir.resolve(Objects.requireNonNull(fileName)), file.bytes)
            UploadManage(HandUtils, IDGenerator).insertUploadFile(uploadModel, uid, fileName, filePath, time, type, file.size)
            if (uploadDao.insert(uploadModel) > 0) {
                ConsoleUtils.printInfoLog("upload file $uid $filePath")
                return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                    init {
                        put("path", filePath)
                    }
                }, "上传成功")
            } else return HandUtils.handleResultByCode(400, null, "上传失败")
        } catch (e: IOException) {
            return HandUtils.printErrorLog(e)
        }
    }
    /**
     * Validates the request by checking user and group existence and token validity.
     *
     * @param uidHeader   user ID from headers.
     * @param gidHeader   group ID from headers.
     * @param tokenHeader token from headers.
     * @return true if the request is valid, false otherwise.
     */
    private fun isValidRequest(
        uidHeader: List<String>?,
        gidHeader: List<String>?,
        tokenHeader: List<String>?
    ): Boolean {
        if (uidHeader == null || gidHeader == null || tokenHeader == null) return false
        val user = serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("uid", uidHeader[0]))
        val group = clientChannelDao.selectOne(QueryWrapper<ClientChannelModel>().eq("gid", gidHeader[0]))
        val isTokenValid = tokenService.validUserToken(uidHeader[0].toLong(), tokenHeader[0])
        return user != null && group != null && isTokenValid
    }
    /**
     * Creates the upload directory for the file.
     *
     * @param uid  user ID.
     * @param time time stamp for directory naming.
     * @return the path to the upload directory.
     * @throws IOException if directory creation fails.
     */
    @Throws(IOException::class)
    private fun createUploadDirectory(type: String, uid: String, time: String): Path {
        val uploadDir = if (type == "avatar") {
            Paths.get("$AVATAR_DIRECTORY$uid/$time/")
        } else if (type == "images") {
            Paths.get("$IMAGES_DIRECTORY$uid/$time/")
        } else Paths.get("$FILES_DIRECTORY$uid/$time/")
        if (!Files.exists(uploadDir)) Files.createDirectories(uploadDir)
        return uploadDir
    }
    companion object {
        private const val FILES_DIRECTORY = "upload/files/"
        private const val AVATAR_DIRECTORY = "upload/avatar/"
        private const val IMAGES_DIRECTORY = "upload/images/"
    }
}
package com.server.handsock.api.open
import com.server.handsock.clients.service.ClientChatService
import com.server.handsock.clients.service.ClientUserService
import com.server.handsock.services.AuthService
import com.server.handsock.services.ClientService
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.RobotUtils
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
@RestController
@RequestMapping("/openapi")
open class OpenAPIController @Autowired constructor(
    private val authService: AuthService,
    private val clientService: ClientService,
    private val clientUserService: ClientUserService,
    private val clientChatService: ClientChatService
) {
    @PostMapping("/robot/send")
    fun sendRobotMessage(@RequestBody data: Map<String?, Any>, request: HttpServletRequest): Any {
        return authService.validOpenApiRequestLimit("Robot-Send", request) {
            if (data["gid"] == null || data["content"] == null) {
                HandUtils.handleResultByCode(400, null, "必填参数不为空")
            } else {
                val gid = data["gid"].toString()
                val content = data["content"].toString()
                RobotUtils.sendRobotMessage(
                    content = content,
                    gid = gid.toLong(),
                    address = request.remoteAddr,
                    clientService = clientService,
                    clientUserService = clientUserService,
                    clientChatService = clientChatService
                )
            }
        }
    }
}
package com.server.handsock.api.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_upload")
public class UploadModel {
    @TableId
    private Long uid;
    private Long size;
    private String fid;
    private String time;
    private String name;
    private String path;
    private String type;
}
package com.server.handsock.api.man;
import com.server.handsock.api.mod.UploadModel;
import com.server.handsock.utils.HandUtils;
import com.server.handsock.utils.IDGenerator;
public class UploadManage {
    private final HandUtils handUtils;
    private final IDGenerator idGenerator;
    public UploadManage(HandUtils handUtils, IDGenerator idGenerator) {
        this.handUtils = handUtils;
        this.idGenerator = idGenerator;
    }
    public void insertUploadFile(UploadModel uploadModel, Long uid, String name, String path, String time, String type, Long size) {
        uploadModel.setFid(idGenerator.generateRandomFileId(uid, name, path, time));
        uploadModel.setUid(uid);
        uploadModel.setName(name);
        uploadModel.setPath(path);
        uploadModel.setType(type);
        uploadModel.setSize(size);
        uploadModel.setTime(handUtils.formatTimeForString("yyyy-MM-dd HH:mm:ss"));
    }
}
package com.server.handsock.api.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.api.mod.UploadModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface UploadDao extends BaseMapper<UploadModel> {}
package com.server.handsock.api.controller
import com.server.handsock.api.service.UploadService
import com.server.handsock.props.HandProp
import com.server.handsock.services.AuthService
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.core.io.Resource
import org.springframework.core.io.UrlResource
import org.springframework.http.*
import org.springframework.web.bind.annotation.*
import org.springframework.web.context.request.RequestContextHolder
import org.springframework.web.context.request.ServletRequestAttributes
import org.springframework.web.multipart.MultipartFile
import java.io.IOException
import java.net.URLEncoder
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths
import java.util.*
@RestController
@RequestMapping("/upload")
class UploadController @Autowired constructor(
    handProp: HandProp,
    private val authService: AuthService,
    private val uploadService: UploadService
) {
    private val crossOriginUrls = handProp.origin
    private val referer: String
        get() {
            val request = (Objects.requireNonNull(RequestContextHolder.getRequestAttributes()) as ServletRequestAttributes).request
            return request.getHeader("Referer") ?: "null"
        }
    @Throws(IOException::class)
    private fun uploadFile(entity: HttpEntity<String>, file: MultipartFile, type: String): Map<String, Any> {
        if (!HandUtils.checkImageValidExtension(file) && ("avatar" == type || "images" == type)) return HandUtils.handleResultByCode(400, null, "不支持的文件类型")
        if (file.isEmpty) return HandUtils.handleResultByCode(400, null, "禁止上传空文件")
        return uploadService.clientUploadFile(
            file = file,
            type = type,
            headers = entity.headers
        )
    }
    @PostMapping("/file")
    @Throws(IOException::class)
    fun clientUploadFile(entity: HttpEntity<String>, @RequestParam("file") file: MultipartFile): Map<String, Any> {
        return uploadFile(
            file = file,
            type = "files",
            entity = entity
        )
    }
    @PostMapping("/avatar")
    @Throws(IOException::class)
    fun clientUploadAvatar(entity: HttpEntity<String>, @RequestParam("file") file: MultipartFile): Map<String, Any> {
        return uploadFile(
            file = file,
            type = "avatar",
            entity = entity
        )
    }
    @PostMapping("/images")
    @Throws(IOException::class)
    fun clientUploadImages(entity: HttpEntity<String>, @RequestParam("file") file: MultipartFile): Map<String, Any> {
        return uploadFile(
            file = file,
            type = "images",
            entity = entity
        )
    }
    private fun downloadFile(uid: String, md5: String, filename: String, directory: String): ResponseEntity<Resource> {
        try {
            val filePath = Paths.get(directory).resolve(uid).resolve(md5).resolve(filename)
            val resource: Resource = UrlResource(filePath.toUri())
            if (resource.exists()) {
                val encodedFilename = URLEncoder.encode(filename, StandardCharsets.UTF_8).replace("\\+".toRegex(), "%20")
                return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename*=UTF-8''$encodedFilename")
                    .contentType(MediaType.parseMediaType(Files.probeContentType(filePath)))
                    .body(resource)
            }
        } catch (e: Exception) {
            ConsoleUtils.printErrorLog(e)
        }
        return ResponseEntity.notFound().build()
    }
    @GetMapping("/download/{type}/{uid}/{md5}/{filename:.+}")
    fun download(
        request: HttpServletRequest,
        @PathVariable type: String?,
        @PathVariable uid: String,
        @PathVariable md5: String,
        @PathVariable filename: String
    ): ResponseEntity<Resource> {
        val referer = referer
        if (!referer.startsWith(crossOriginUrls!!)) {
            val token = request.getHeader("token")
            val requestUid = request.getHeader("uid")
            if (token == null || requestUid == null || !authService.validClientTokenByRequest(request)) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN).build()
            }
        }
        val directory = when (type) {
            "file" -> UPLOAD_DIRECTORIES[0]
            "avatar" -> UPLOAD_DIRECTORIES[1]
            "images" -> UPLOAD_DIRECTORIES[2]
            else -> return ResponseEntity.status(HttpStatus.BAD_REQUEST).build()
        }
        return downloadFile(
            uid = uid,
            md5 = md5,
            filename = filename,
            directory = directory
        )
    }
    companion object {
        private val UPLOAD_DIRECTORIES = arrayOf("upload/files/", "upload/avatar/", "upload/images/")
    }
}
package com.server.handsock.admin.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerChatDao
import com.server.handsock.admin.dao.ServerUserDao
import com.server.handsock.admin.man.ServerUserManage
import com.server.handsock.admin.mod.ServerChatModel
import com.server.handsock.admin.mod.ServerUserModel
import com.server.handsock.clients.dao.ClientUserDao
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import kotlin.math.min
@Service
class ServerUserService @Autowired constructor(
    private val serverUserDao: ServerUserDao,
    private val serverChatDao: ServerChatDao,
    private val clientUserDao: ClientUserDao
) {
    fun getUserList(page: Int, limit: Int): Map<String, Any> {
        try {
            val serverUserModelList = serverUserDao.selectList(null)
            val startWith = (page - 1) * limit
            serverUserModelList.reverse()
            val endWith = min((startWith + limit).toDouble(), serverUserModelList.size.toDouble()).toInt()
            val subList: List<ServerUserModel?> = serverUserModelList.subList(startWith, endWith)
            return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                init {
                    put("items", subList)
                    put("total", serverUserModelList.size)
                }
            }, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun deleteUser(uid: Long?): Map<String, Any> {
        try {
            val serverChatModel = serverChatDao.selectList(QueryWrapper<ServerChatModel>().eq("uid", uid))
            if (clientUserDao.selectById(uid).isAdmin == 1) return HandUtils.handleResultByCode(409, null, "无法操作管理员账号")
            if (serverChatModel.isEmpty()) {
                if (serverUserDao.deleteById(uid) > 0) return HandUtils.handleResultByCode(200, null, "删除成功")
            } else {
                if (serverUserDao.deleteById(uid) > 0 && serverChatDao.delete(QueryWrapper<ServerChatModel>().eq("uid", uid)) > 0) return HandUtils.handleResultByCode(200, null, "删除成功")
            }
            return HandUtils.handleResultByCode(400, null, "删除失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun updateUserPassword(uid: Long?, password: String?): Map<String, Any> {
        try {
            val serverUserModel = ServerUserModel()
            ServerUserManage(HandUtils).updateUserPassword(serverUserModel, uid, password)
            return if (serverUserDao.updateById(serverUserModel) > 0) {
                HandUtils.handleResultByCode(200, null, "修改成功")
            } else HandUtils.handleResultByCode(400, null, "修改失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun updateUserTabooStatus(uid: Long?, status: String?): Map<String, Any> {
        try {
            val serverUserModel = ServerUserModel()
            ServerUserManage(HandUtils).updateUserTabooStatus(serverUserModel, uid, status)
            return if (serverUserDao.updateById(serverUserModel) > 0) {
                HandUtils.handleResultByCode(200, null, "设置成功")
            } else HandUtils.handleResultByCode(400, null, "设置失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun updateUserInfo(uid: Long?, username: String?, nick: String?, avatar: String?, robot: Boolean): Map<String, Any> {
        try {
            if (serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("uid", uid)) == null) return HandUtils.handleResultByCode(409, null, "用户不存在")
            val serverUserModel = ServerUserModel()
            val robotModel = serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("is_robot", 1))
            if (robot) {
                if (robotModel != null) {
                    robotModel.isRobot = 0
                    ServerUserManage(HandUtils).updateUserInfo(serverUserModel, uid, username, nick, avatar, 1)
                    if (serverUserDao.updateById(robotModel) > 0 && serverUserDao.updateById(serverUserModel) > 0) return HandUtils.handleResultByCode(200, null, "修改成功")
                } else {
                    ServerUserManage(HandUtils).updateUserInfo(serverUserModel, uid, username, nick, avatar, 1)
                    if (serverUserDao.updateById(serverUserModel) > 0) return HandUtils.handleResultByCode(200, null, "修改成功")
                }
            } else {
                ServerUserManage(HandUtils).updateUserInfo(serverUserModel, uid, username, nick, avatar, 0)
                if (serverUserDao.updateById(serverUserModel) > 0) return HandUtils.handleResultByCode(200, null, "修改成功")
            }
            return HandUtils.handleResultByCode(400, null, "修改失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun getUserInfo(uid: Long): ServerUserModel { // 谨慎使用此方法
        return serverUserDao.selectOne(QueryWrapper<ServerUserModel>().eq("uid", uid))
    }
}
package com.server.handsock.admin.service
import com.server.handsock.admin.dao.ServerUploadDao
import com.server.handsock.admin.mod.ServerUploadModel
import com.server.handsock.utils.ConsoleUtils
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import java.io.File
import kotlin.math.min
@Service
class ServerUploadService @Autowired constructor(private val serverUploadDao: ServerUploadDao) {
    fun getUploadList(page: Int, limit: Int): Map<String, Any> {
        try {
            val serverUploadModelList = serverUploadDao.selectList(null)
            val startWith = (page - 1) * limit
            val total = serverUploadModelList.size
            serverUploadModelList.reverse()
            val endWith = min((startWith + limit).toDouble(), serverUploadModelList.size.toDouble()).toInt()
            val subList: List<ServerUploadModel?> = serverUploadModelList.subList(startWith, endWith)
            return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                init {
                    put("items", subList)
                    put("total", total)
                }
            }, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun deleteUpload(fid: String): Map<String, Any> {
        try {
            deleteUploadFile(fid)
            return if (serverUploadDao.deleteById(fid) > 0) {
                HandUtils.handleResultByCode(200, null, "删除成功")
            } else HandUtils.handleResultByCode(400, null, "删除失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    private fun deleteUploadFile(fid: String) {
        try {
            val serverUploadModel = serverUploadDao.selectById(fid)
            val uploadFile = File("upload/${serverUploadModel.type}/${serverUploadModel.path}")
            if (uploadFile.exists() && uploadFile.delete()) {
                ConsoleUtils.printInfoLog("File deleted $fid")
                ConsoleUtils.printInfoLog("$serverUploadModel.path deleted")
            } else ConsoleUtils.printErrorLog(Exception("File delete failed $fid"))
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.admin.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerSystemDao
import com.server.handsock.admin.man.ServerSystemManage
import com.server.handsock.admin.mod.ServerSystemModel
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
@Service
class ServerSystemService @Autowired constructor(private val serverSystemDao: ServerSystemDao) {
    fun getSystemKeyStatus(key: String?): Boolean {
        try {
            val serverSystemModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", key))
            if (serverSystemModel != null) return serverSystemModel.value == "open"
            return false
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
            return false
        }
    }
    fun getSystemKeyConfig(key: String?): Map<String, Any> {
        val serverSystemModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", key))
        return HandUtils.handleResultByCode(200, serverSystemModel.value, "获取成功")
    }
    fun setSystemTabooStatus(value: String?): Map<String, Any> {
        try {
            val serverSystemModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", "taboo"))
            val result = ServerSystemManage().setSystemKeyStatus(serverSystemModel, value)
            return if (serverSystemDao.updateById(serverSystemModel) > 0) {
                HandUtils.handleResultByCode(200, result, "设置状态成功")
            } else HandUtils.handleResultByCode(200, null, "设置状态失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun setSystemUploadStatus(value: String?): Map<String, Any> {
        try {
            val serverSystemModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", "upload"))
            val result = ServerSystemManage().setSystemKeyStatus(serverSystemModel, value)
            return if (serverSystemDao.updateById(serverSystemModel) > 0) {
                HandUtils.handleResultByCode(200, result, "设置状态成功")
            } else HandUtils.handleResultByCode(200, null, "设置状态失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun setSystemRegisterStatus(value: String?): Map<String, Any> {
        try {
            val serverSystemModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", "register"))
            val result = ServerSystemManage().setSystemKeyStatus(serverSystemModel, value)
            return if (serverSystemDao.updateById(serverSystemModel) > 0) {
                HandUtils.handleResultByCode(200, result, "设置状态成功")
            } else HandUtils.handleResultByCode(200, null, "设置状态失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun setSystemConfigValue(name: String?, value: String?): Map<String, Any> {
        try {
            val serverSystemModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", name))
                ?: return HandUtils.handleResultByCode(400, null, "未知选项")
            val result = ServerSystemManage().setSystemKeyStatus(serverSystemModel, value)
            return if (serverSystemDao.updateById(serverSystemModel) > 0) {
                HandUtils.handleResultByCode(200, result, "设置成功")
            } else HandUtils.handleResultByCode(200, null, "设置失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun checkAppUpdate(version: String?): Map<String, Any> {
        return try {
            val versionModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", "version"))
            if (version != versionModel.value) {
                val downloadModel = serverSystemDao.selectOne(QueryWrapper<ServerSystemModel>().eq("name", "download"))
                HandUtils.handleResultByCode(201, mapOf(
                    "version" to versionModel.value,
                    "download" to downloadModel.value
                ), "有新版本可更新")
            } else HandUtils.handleResultByCode(200, null, "已是最新版本")
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
        }
    }
    val allSystemConfig: Map<String, Any>
        get() {
            try {
                val serverSystemModelList = serverSystemDao.selectList(null)
                return HandUtils.handleResultByCode(200, serverSystemModelList, "获取成功")
            } catch (e: Exception) {
                return HandUtils.printErrorLog(e)
            }
        }
}
package com.server.handsock.admin.service
import com.server.handsock.admin.dao.ServerReportDao
import com.server.handsock.admin.mod.ServerReportModel
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import kotlin.math.min
@Service
class ServerReportService @Autowired constructor(private val serverReportDao: ServerReportDao) {
    fun getReportList(page: Int, limit: Int): Map<String, Any> {
        try {
            val serverReportModelList = serverReportDao.selectList(null)
            val total = serverReportModelList.size
            val startWith = (page - 1) * limit
            serverReportModelList.reverse()
            val endWith = min((startWith + limit).toDouble(), serverReportModelList.size.toDouble()).toInt()
            val subList: List<ServerReportModel?> = serverReportModelList.subList(startWith, endWith)
            return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                init {
                    put("items", subList)
                    put("total", total)
                }
            }, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun deleteReport(sid: String?): Map<String, Any> {
        return try {
            if (serverReportDao.deleteById(sid) > 0) {
                HandUtils.handleResultByCode(200, null, "删除成功")
            } else HandUtils.handleResultByCode(400, null, "删除失败")
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.admin.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerNoticeDao
import com.server.handsock.admin.man.ServerNoticeManage
import com.server.handsock.admin.mod.ServerNoticeModel
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import kotlin.math.min
@Service
class ServerNoticeService @Autowired constructor(private val serverNoticeDao: ServerNoticeDao) {
    fun getNoticeList(page: Int, limit: Int): Map<String, Any> {
        try {
            val serverNoticeModelList = serverNoticeDao.selectList(null)
            val total = serverNoticeModelList.size
            val startWith = (page - 1) * limit
            serverNoticeModelList.reverse()
            val endWith = min((startWith + limit).toDouble(), serverNoticeModelList.size.toDouble()).toInt()
            val subList: List<ServerNoticeModel?> = serverNoticeModelList.subList(startWith, endWith)
            return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                init {
                    put("items", subList)
                    put("total", total)
                }
            }, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun deleteNotice(nid: Int): Map<String, Any> {
        return try {
            if (serverNoticeDao.deleteById(nid) > 0) {
                HandUtils.handleResultByCode(200, null, "删除成功")
            } else HandUtils.handleResultByCode(400, null, "删除失败")
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
        }
    }
    fun updateNotice(nid: Int, title: String?, content: String?): Map<String, Any> {
        try {
            if (serverNoticeDao.selectOne(QueryWrapper<ServerNoticeModel>().eq("nid", nid)) == null) return HandUtils.handleResultByCode(409, null, "公告不存在")
            val serverNoticeModel = ServerNoticeModel()
            ServerNoticeManage().updateNotice(serverNoticeModel, nid, title, content)
            return if (serverNoticeDao.updateById(serverNoticeModel) > 0) {
                HandUtils.handleResultByCode(200, null, "修改成功")
            } else HandUtils.handleResultByCode(400, null, "修改失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun createNotice(title: String?, content: String?): Map<String, Any> {
        try {
            val serverNoticeModel = ServerNoticeModel()
            ServerNoticeManage().setNotice(serverNoticeModel, title, content)
            return if (serverNoticeDao.insert(serverNoticeModel) > 0) {
                HandUtils.handleResultByCode(200, null, "创建成功")
            } else HandUtils.handleResultByCode(400, null, "创建失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.admin.service
import com.server.handsock.utils.HandUtils
import org.springframework.stereotype.Service
import java.nio.file.Files
import java.nio.file.Paths
@Service
class ServerLogService {
    val systemLogs: Map<String, Any>
        get() {
            val contentBuilder = StringBuilder()
            try {
                Files.lines(Paths.get(FILE_PATH)).use { lines ->
                    lines.forEach { line: String? -> contentBuilder.append(line).append(System.lineSeparator()) }
                    return HandUtils.handleResultByCode(200, contentBuilder.toString(), "获取成功")
                }
            } catch (e: Exception) {
                return HandUtils.printErrorLog(e)
            }
        }
    fun deleteSystemLogs(): Map<String, Any> {
        try {
            Files.write(Paths.get(FILE_PATH), ByteArray(0))
            return HandUtils.handleResultByCode(200, null, "日志清空成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    companion object {
        private const val FILE_PATH = "server.log"
    }
}
package com.server.handsock.admin.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.baomidou.mybatisplus.core.mapper.BaseMapper
import com.server.handsock.admin.dao.ServerChannelDao
import com.server.handsock.admin.dao.ServerChatDao
import com.server.handsock.admin.dao.ServerUserDao
import com.server.handsock.props.HandProp
import com.server.handsock.utils.HandUtils
import com.server.handsock.utils.SystemUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.i18n.LocaleContextHolder
import org.springframework.stereotype.Service
import oshi.SystemInfo
import java.io.IOException
import java.net.InetAddress
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.format.DateTimeFormatter
import java.util.*
@Service
class ServerDashService @Autowired constructor(
    private val handProp: HandProp,
    private val serverChatDao: ServerChatDao,
    private val serverUserDao: ServerUserDao,
    private val serverChannelDao: ServerChannelDao
) {
    private val dateFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
    val dashboardData: Map<String, Any>
        get() {
            try {
                val today = LocalDate.now()
                val startOfDay = today.atStartOfDay()
                val endOfDay = today.atTime(LocalTime.MAX)
                val userTotal = serverUserDao.selectCount(null)
                val chanTotal = serverChannelDao.selectCount(null)
                val todayRegUser = countRecordsInRange(serverUserDao, "reg_time", startOfDay, endOfDay)
                val todayChatTotal = countRecordsInRange(serverChatDao, "time", startOfDay, endOfDay)
                val result: MutableMap<String, Any> = HashMap()
                result["userTotal"] = userTotal
                result["chanTotal"] = chanTotal
                result["todayRegUser"] = todayRegUser
                result["todayChatTotal"] = todayChatTotal
                result["systemOsInfo"] = systemOsInfo
                return HandUtils.handleResultByCode(200, result, "获取成功")
            } catch (e: Exception) {
                return HandUtils.printErrorLog(e)
            }
        }
    @get:Throws(IOException::class)
    val systemOsInfo: HashMap<String?, Any?>
        get() {
            val si = SystemInfo()
            val hal = si.hardware
            val processor = hal.processor
            val localHost = InetAddress.getLocalHost()
            return object : HashMap<String?, Any?>() {
                init {
                    put("osInfo", System.getProperty("os.name"))
                    put("osArch", System.getProperty("os.arch"))
                    put("locale", LocaleContextHolder.getLocale())
                    put("hostName", localHost.hostName)
                    put("appVersion", handProp.appVersion)
                    put("timeZoneId", TimeZone.getDefault().id)
                    put("hostAddress", localHost.hostAddress)
                    put("systemUptime", SystemUtils.systemUptime)
                    put("logicalCount", processor.logicalProcessorCount)
                    put("memoryUsageInfo", SystemUtils.systemMemoryUsage)
                }
            }
        }
    private fun <T> countRecordsInRange(dao: BaseMapper<T>, timeField: String, start: LocalDateTime, end: LocalDateTime): Long {
        val queryWrapper = QueryWrapper<T>()
        queryWrapper.ge(timeField, start.format(dateFormatter))
        queryWrapper.lt(timeField, end.format(dateFormatter))
        return dao.selectCount(queryWrapper)
    }
}
package com.server.handsock.admin.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerChatDao
import com.server.handsock.admin.mod.ServerChatModel
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import kotlin.math.min
@Service
class ServerChatService @Autowired constructor(private val serverChatDao: ServerChatDao) {
    fun getChatContent(sid: String?): Map<String, Any> {
        try {
            val serverChatModel = serverChatDao.selectOne(QueryWrapper<ServerChatModel>().eq("sid", sid))
            return if (serverChatModel != null) {
                HandUtils.handleResultByCode(200, serverChatModel, "获取成功")
            } else HandUtils.handleResultByCode(501, null, "内容已被删除")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun getChatList(page: Int, limit: Int): Map<String, Any> {
        try {
            val serverChatModelList = serverChatDao.selectList(null)
            val total = serverChatModelList.size
            val startWith = (page - 1) * limit
            serverChatModelList.reverse()
            val endWith = min((startWith + limit).toDouble(), serverChatModelList.size.toDouble()).toInt()
            val subList: List<ServerChatModel?> = serverChatModelList.subList(startWith, endWith)
            return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                init {
                    put("items", subList)
                    put("total", total)
                }
            }, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun deleteChat(sid: String?): Map<String, Any> {
        try {
            val serverChatModel = serverChatDao.selectOne(QueryWrapper<ServerChatModel>().eq("sid", sid))
            return if (serverChatModel != null) {
                if (serverChatDao.deleteById(sid) > 0) {
                    HandUtils.handleResultByCode(200, null, "删除成功")
                } else HandUtils.handleResultByCode(400, null, "删除失败")
            } else HandUtils.handleResultByCode(501, null, "消息已被删除")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun clearAllChatHistory() {
        try {
            if (serverChatDao.delete(null) > 0) {
                HandUtils.handleResultByCode(200, null, "清空聊天记录成功")
            } else HandUtils.handleResultByCode(400, null, "清空聊天记录成功失败")
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.admin.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerChannelDao
import com.server.handsock.admin.dao.ServerChatDao
import com.server.handsock.admin.man.ServerChannelManage
import com.server.handsock.admin.mod.ServerChannelModel
import com.server.handsock.admin.mod.ServerChatModel
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import kotlin.math.min
@Service
class ServerChannelService @Autowired constructor(
    private val serverChatDao: ServerChatDao,
    private val serverChannelDao: ServerChannelDao
) {
    fun getChanList(page: Int, limit: Int): Map<String, Any> {
        try {
            val serverChannelModelList = serverChannelDao.selectList(null)
            val total = serverChannelModelList.size
            val startWith = (page - 1) * limit
            val endWith = min((startWith + limit).toDouble(), serverChannelModelList.size.toDouble()).toInt()
            val subList: List<ServerChannelModel?> = serverChannelModelList.subList(startWith, endWith)
            return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                init {
                    put("items", subList)
                    put("total", total)
                }
            }, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun deleteChan(gid: Long): Map<String, Any> {
        if (gid == 0L) return HandUtils.handleResultByCode(409, null, "主频道不可操作")
        try {
            val serverChatModel = serverChatDao.selectList(QueryWrapper<ServerChatModel>().eq("gid", gid))
            if (serverChatModel.isEmpty()) {
                if (serverChannelDao.deleteById(gid) > 0) return HandUtils.handleResultByCode(200, null, "删除成功")
            } else {
                if (serverChannelDao.deleteById(gid) > 0 && serverChatDao.delete(QueryWrapper<ServerChatModel>().eq("gid", gid)) > 0) return HandUtils.handleResultByCode(200, null, "删除成功")
            }
            return HandUtils.handleResultByCode(400, null, "删除失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun updateChan(gid: Long?, name: String?, avatar: String?, notice: String?, aiRole: Boolean?): Map<String, Any> {
        try {
            if (serverChannelDao.selectOne(QueryWrapper<ServerChannelModel>().eq("gid", gid)) == null) return HandUtils.handleResultByCode(409, null, "频道不存在")
            val serverChannelModel = ServerChannelModel()
            ServerChannelManage().setChan(serverChannelModel, gid, name, avatar, notice, aiRole)
            return if (serverChannelDao.updateById(serverChannelModel) > 0) {
                HandUtils.handleResultByCode(200, null, "修改成功")
            } else HandUtils.handleResultByCode(400, null, "修改失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun createChan(gid: Long?, name: String?, avatar: String?, notice: String?, aiRole: Boolean?): Map<String, Any> {
        try {
            if (serverChannelDao.selectOne(QueryWrapper<ServerChannelModel>().eq("gid", gid)) != null) return HandUtils.handleResultByCode(409, null, "频道已存在")
            val serverChannelModel = ServerChannelModel()
            ServerChannelManage().setChan(serverChannelModel, gid, name, avatar, notice, aiRole)
            return if (serverChannelDao.insert(serverChannelModel) > 0) {
                HandUtils.handleResultByCode(200, null, "创建成功")
            } else HandUtils.handleResultByCode(400, null, "创建失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun updateChanOpenStatus(gid: Long, status: Int?): Map<String, Any> {
        if (gid == 0L) return HandUtils.handleResultByCode(409, null, "主频道不可操作")
        try {
            val serverChannelModel = ServerChannelModel()
            ServerChannelManage().updateChanOpenStatus(serverChannelModel, gid, status)
            return if (serverChannelDao.updateById(serverChannelModel) > 0) {
                HandUtils.handleResultByCode(200, null, "设置成功")
            } else HandUtils.handleResultByCode(400, null, "设置失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun updateChanActiveStatus(gid: Long, status: Int?): Map<String, Any> {
        if (gid == 0L) return HandUtils.handleResultByCode(409, null, "主频道不可操作")
        try {
            val serverChannelModel = ServerChannelModel()
            ServerChannelManage().updateChanActiveStatus(serverChannelModel, gid, status)
            return if (serverChannelDao.updateById(serverChannelModel) > 0) {
                HandUtils.handleResultByCode(200, null, "设置成功")
            } else HandUtils.handleResultByCode(400, null, "设置失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.admin.service
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper
import com.server.handsock.admin.dao.ServerBannerDao
import com.server.handsock.admin.man.ServerBannerManage
import com.server.handsock.admin.mod.ServerBannerModel
import com.server.handsock.utils.HandUtils
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import kotlin.math.min
@Service
class ServerBannerService @Autowired constructor(private val serverBannerDao: ServerBannerDao) {
    fun getBannerList(page: Int, limit: Int): Map<String, Any> {
        try {
            val serverBannerModelList = serverBannerDao.selectList(null)
            val total = serverBannerModelList.size
            val startWith = (page - 1) * limit
            val endWith = min((startWith + limit).toDouble(), serverBannerModelList.size.toDouble()).toInt()
            val subList: List<ServerBannerModel?> = serverBannerModelList.subList(startWith, endWith)
            return HandUtils.handleResultByCode(200, object : HashMap<Any?, Any?>() {
                init {
                    put("items", subList)
                    put("total", total)
                }
            }, "获取成功")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun deleteBanner(bid: Int): Map<String, Any> {
        return try {
            if (serverBannerDao.deleteById(bid) > 0) {
                HandUtils.handleResultByCode(200, null, "删除成功")
            } else HandUtils.handleResultByCode(400, null, "删除失败")
        } catch (e: Exception) {
            HandUtils.printErrorLog(e)
        }
    }
    fun updateBanner(bid: Int, name: String?, href: String?, image: String?): Map<String, Any> {
        try {
            if (serverBannerDao.selectOne(QueryWrapper<ServerBannerModel>().eq("bid", bid)) == null) return HandUtils.handleResultByCode(409, null, "轮播不存在")
            val serverBannerModel = ServerBannerModel()
            ServerBannerManage().updateBanner(serverBannerModel, bid, name, href, image)
            return if (serverBannerDao.updateById(serverBannerModel) > 0) {
                HandUtils.handleResultByCode(200, null, "修改成功")
            } else HandUtils.handleResultByCode(400, null, "修改失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
    fun createBanner(name: String?, href: String?, image: String?): Map<String, Any> {
        try {
            val serverBannerModel = ServerBannerModel()
            ServerBannerManage().setBanner(serverBannerModel, name, href, image)
            return if (serverBannerDao.insert(serverBannerModel) > 0) {
                HandUtils.handleResultByCode(200, null, "创建成功")
            } else HandUtils.handleResultByCode(400, null, "创建失败")
        } catch (e: Exception) {
            return HandUtils.printErrorLog(e)
        }
    }
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_user")
public class ServerUserModel {
    @TableId
    public Long uid;
    public String nick;
    public String taboo;
    public String avatar;
    public String regTime;
    public Integer isAdmin;
    public String username;
    public String password;
    public Integer isRobot;
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_upload")
public class ServerUploadModel {
    @TableId
    public String fid;
    public Long uid;
    public Long size;
    public String time;
    public String name;
    public String path;
    public String type;
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_system")
public class ServerSystemModel {
    @TableId
    public Integer yid;
    public String time;
    public String name;
    public String value;
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_report")
public class ServerReportModel {
    @TableId
    public String rid;
    public String sid;
    public String time;
    public String reason;
    public Long reporterId;
    public Long reportedId;
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_notice")
public class ServerNoticeModel {
    @TableId
    private Integer nid;
    private String time;
    private String title;
    private String content;
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_message")
public class ServerChatModel {
    public Long uid;
    public Long gid;
    @TableId
    public String sid;
    public String type;
    public String time;
    public Integer deleted;
    public String address;
    public String content;
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_channel")
public class ServerChannelModel {
    @TableId
    public Long gid;
    public String name;
    public Integer home;
    public Integer open;
    public String notice;
    public String avatar;
    public Integer active;
    public Integer aiRole;
}
package com.server.handsock.admin.mod;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
@Data
@TableName("handsock_banner")
public class ServerBannerModel {
    @TableId
    private Integer bid;
    private String name;
    private String href;
    private String image;
}
package com.server.handsock.admin.man;
import com.server.handsock.admin.mod.ServerUserModel;
import com.server.handsock.utils.HandUtils;
public class ServerUserManage {
    private final HandUtils handUtils;
    public ServerUserManage(HandUtils handUtils) {
        this.handUtils = handUtils;
    }
    public void updateUserPassword(ServerUserModel server_userModel, Long uid, String password) {
        server_userModel.setUid(uid);
        server_userModel.setPassword(handUtils.encodeStringToMD5(password));
    }
    public void updateUserInfo(ServerUserModel server_userModel, Long uid, String username, String nick, String avatar, Integer robot) {
        server_userModel.setUid(uid);
        server_userModel.setNick(nick);
        server_userModel.setAvatar(avatar);
        server_userModel.setIsRobot(robot);
        server_userModel.setUsername(username);
    }
    public void updateUserTabooStatus(ServerUserModel server_userModel, Long uid, String status) {
        server_userModel.setUid(uid);
        server_userModel.setTaboo(status);
    }
}
package com.server.handsock.admin.man;
import com.server.handsock.admin.mod.ServerSystemModel;
import java.util.HashMap;
import java.util.Map;
public class ServerSystemManage {
    public Map<String, Object> setSystemKeyStatus(ServerSystemModel OUSystemModel, String value) {
        OUSystemModel.setValue(value);
        return new HashMap<>() {{
            put("status", OUSystemModel.getValue());
        }};
    }
}
package com.server.handsock.admin.man;
import com.server.handsock.admin.mod.ServerNoticeModel;
public class ServerNoticeManage {
    public void setNotice(ServerNoticeModel serverNoticeModel, String title, String content) {
        serverNoticeModel.setTitle(title);
        serverNoticeModel.setContent(content);
    }
    public void updateNotice(ServerNoticeModel serverNoticeModel, Integer nid, String title, String content) {
        serverNoticeModel.setNid(nid);
        setNotice(serverNoticeModel, title, content);
    }
}
package com.server.handsock.admin.man;
import com.server.handsock.admin.mod.ServerChannelModel;
public class ServerChannelManage {
    public void setChan(ServerChannelModel serverChannelModel, Long gid, String name, String avatar, String notice, Boolean aiRole) {
        serverChannelModel.setGid(gid);
        serverChannelModel.setName(name);
        serverChannelModel.setAvatar(avatar);
        serverChannelModel.setNotice(notice);
        serverChannelModel.setAiRole(aiRole ? 1 : 0);
    }
    public void updateChanOpenStatus(ServerChannelModel serverChannelModel, Long gid, Integer status) {
        serverChannelModel.setGid(gid);
        serverChannelModel.setOpen(status);
    }
    public void updateChanActiveStatus(ServerChannelModel serverChannelModel, Long gid, Integer status) {
        serverChannelModel.setGid(gid);
        serverChannelModel.setActive(status);
    }
}
package com.server.handsock.admin.man;
import com.server.handsock.admin.mod.ServerBannerModel;
public class ServerBannerManage {
    public void setBanner(ServerBannerModel serverBannerModel, String name, String href, String image) {
        serverBannerModel.setName(name);
        serverBannerModel.setHref(href);
        serverBannerModel.setImage(image);
    }
    public void updateBanner(ServerBannerModel serverBannerModel, Integer bid, String name, String href, String image) {
        serverBannerModel.setBid(bid);
        setBanner(serverBannerModel, name, href, image);
    }
}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerUserModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerUserDao extends BaseMapper<ServerUserModel> {
}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerUploadModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerUploadDao extends BaseMapper<ServerUploadModel> {
}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerSystemModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerSystemDao extends BaseMapper<ServerSystemModel> {
}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerReportModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerReportDao extends BaseMapper<ServerReportModel> {
}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerNoticeModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerNoticeDao extends BaseMapper<ServerNoticeModel> {}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerChatModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerChatDao extends BaseMapper<ServerChatModel> {
}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerChannelModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerChannelDao extends BaseMapper<ServerChannelModel> {
}
package com.server.handsock.admin.dao;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.handsock.admin.mod.ServerBannerModel;
import org.apache.ibatis.annotations.Mapper;
@Mapper
public interface ServerBannerDao extends BaseMapper<ServerBannerModel> {}
package com.server.handsock.admin.controller
import com.server.handsock.admin.service.ServerUserService
import com.server.handsock.services.AuthService
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
@RestController
@RequestMapping("/admin/user")
class ServerUserController @Autowired constructor(
    private val authService: AuthService,
    private val serverUserService: ServerUserService
) {
    @PostMapping("/set/taboo")
    fun updateUserTabooStatus(request: HttpServletRequest, @RequestBody data: Map<String?, Any>): Any {
        return authService.validAdminStatusByRequest(request) {
            val status = data["status"].toString()
            val uid = data["uid"].toString().toLong()
            serverUserService.updateUserTabooStatus(uid, status)
        }
    }
    @PostMapping("/set/info")
    fun updateUserInfo(request: HttpServletRequest, @RequestBody data: Map<String?, Any>): Any {
        return authService.validAdminStatusByRequest(request) {
            val nick = data["nick"].toString()
            val avatar = data["avatar"].toString()
            val uid = data["uid"].toString().toLong()
            val username = data["username"].toString()
            val robot = data["robot"].toString().toBoolean()
            serverUserService.updateUserInfo(uid, username, nick, avatar, robot)
        }
    }
}
package com.server.handsock.admin.controller
import com.server.handsock.admin.service.ServerDashService
import com.server.handsock.services.AuthService
import jakarta.servlet.http.HttpServletRequest
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
@RestController
@RequestMapping("/admin/dash")
class ServerDashController @Autowired constructor(
    private val authService: AuthService,
    private val serverDashService: ServerDashService
) {
    @GetMapping("/data")
    fun getDashboardData(request: HttpServletRequest): Any {
        return authService.validAdminStatusByRequest(request) {
            serverDashService.dashboardData
        }
    }
}
